{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    throw: verb(1),\n    return: verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setFrontToken = exports.getFrontToken = exports.setAntiCSRF = exports.setIdRefreshToken = exports.getIdRefreshToken = exports.onInvalidClaimResponse = exports.onTokenUpdate = exports.onUnauthorisedResponse = exports.FrontToken = exports.AntiCsrfToken = void 0;\n/* Copyright (c) 2020, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\nvar processState_1 = require(\"./processState\");\nvar version_1 = require(\"./version\");\nvar browser_tabs_lock_1 = require(\"browser-tabs-lock\");\nvar utils_1 = require(\"./utils\");\nvar cookieHandler_1 = require(\"./utils/cookieHandler\");\nvar windowHandler_1 = require(\"./utils/windowHandler\");\nvar logger_1 = require(\"./logger\");\nfunction getWindowOrThrow() {\n  if (typeof window === \"undefined\") {\n    throw Error(\"If you are using this package with server-side rendering, please make sure that you are checking if the window object is defined.\");\n  }\n  return window;\n}\nvar AntiCsrfToken = /** @class */function () {\n  function AntiCsrfToken() {}\n  AntiCsrfToken.getToken = function (associatedIdRefreshToken) {\n    return __awaiter(this, void 0, void 0, function () {\n      var antiCsrf;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: called\");\n            if (associatedIdRefreshToken === undefined) {\n              AntiCsrfToken.tokenInfo = undefined;\n              (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: returning undefined\");\n              return [2 /*return*/, undefined];\n            }\n            if (!(AntiCsrfToken.tokenInfo === undefined)) return [3 /*break*/, 2];\n            return [4 /*yield*/, getAntiCSRFToken()];\n          case 1:\n            antiCsrf = _a.sent();\n            if (antiCsrf === null) {\n              (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: returning undefined\");\n              return [2 /*return*/, undefined];\n            }\n            AntiCsrfToken.tokenInfo = {\n              antiCsrf: antiCsrf,\n              associatedIdRefreshToken: associatedIdRefreshToken\n            };\n            return [3 /*break*/, 4];\n          case 2:\n            if (!(AntiCsrfToken.tokenInfo.associatedIdRefreshToken !== associatedIdRefreshToken)) return [3 /*break*/, 4];\n            // csrf token has changed.\n            AntiCsrfToken.tokenInfo = undefined;\n            return [4 /*yield*/, AntiCsrfToken.getToken(associatedIdRefreshToken)];\n          case 3:\n            return [2 /*return*/, _a.sent()];\n          case 4:\n            (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: returning: \" + AntiCsrfToken.tokenInfo.antiCsrf);\n            return [2 /*return*/, AntiCsrfToken.tokenInfo.antiCsrf];\n        }\n      });\n    });\n  };\n  AntiCsrfToken.removeToken = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            (0, logger_1.logDebugMessage)(\"AntiCsrfToken.removeToken: called\");\n            AntiCsrfToken.tokenInfo = undefined;\n            return [4 /*yield*/, setAntiCSRF(undefined)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  AntiCsrfToken.setItem = function (associatedIdRefreshToken, antiCsrf) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (associatedIdRefreshToken === undefined) {\n              AntiCsrfToken.tokenInfo = undefined;\n              return [2 /*return*/];\n            }\n\n            (0, logger_1.logDebugMessage)(\"AntiCsrfToken.setItem: called\");\n            return [4 /*yield*/, setAntiCSRF(antiCsrf)];\n          case 1:\n            _a.sent();\n            AntiCsrfToken.tokenInfo = {\n              antiCsrf: antiCsrf,\n              associatedIdRefreshToken: associatedIdRefreshToken\n            };\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return AntiCsrfToken;\n}();\nexports.AntiCsrfToken = AntiCsrfToken;\n// Note: We do not store this in memory because another tab may have\n// modified this value, and if so, we may not know about it in this tab\nvar FrontToken = /** @class */function () {\n  function FrontToken() {}\n  FrontToken.getTokenInfo = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var frontToken, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: called\");\n            return [4 /*yield*/, getFrontToken()];\n          case 1:\n            frontToken = _a.sent();\n            if (!(frontToken === null)) return [3 /*break*/, 5];\n            return [4 /*yield*/, getIdRefreshToken(false)];\n          case 2:\n            if (!(_a.sent().status === \"EXISTS\")) return [3 /*break*/, 4];\n            // this means that the id refresh token has been set, so we must\n            // wait for this to be set or removed\n            return [4 /*yield*/, new Promise(function (resolve) {\n              FrontToken.waiters.push(resolve);\n            })];\n          case 3:\n            // this means that the id refresh token has been set, so we must\n            // wait for this to be set or removed\n            _a.sent();\n            return [2 /*return*/, FrontToken.getTokenInfo()];\n          case 4:\n            return [2 /*return*/, undefined];\n          case 5:\n            response = parseFrontToken(frontToken);\n            (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: returning ate: \" + response.ate);\n            (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: returning uid: \" + response.uid);\n            (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: returning up: \" + response.up);\n            return [2 /*return*/, response];\n        }\n      });\n    });\n  };\n  FrontToken.removeToken = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            (0, logger_1.logDebugMessage)(\"FrontToken.removeToken: called\");\n            return [4 /*yield*/, setFrontToken(undefined)];\n          case 1:\n            _a.sent();\n            FrontToken.waiters.forEach(function (f) {\n              return f(undefined);\n            });\n            FrontToken.waiters = [];\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  FrontToken.setItem = function (frontToken) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            (0, logger_1.logDebugMessage)(\"FrontToken.setItem: called\");\n            return [4 /*yield*/, setFrontToken(frontToken)];\n          case 1:\n            _a.sent();\n            FrontToken.waiters.forEach(function (f) {\n              return f(undefined);\n            });\n            FrontToken.waiters = [];\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  // these are waiters for when the idRefreshToken has been set, but this token has\n  // not yet been set. Once this token is set or removed, the waiters are resolved.\n  FrontToken.waiters = [];\n  return FrontToken;\n}();\nexports.FrontToken = FrontToken;\n/**\n * @class AuthHttpRequest\n * @description wrapper for common http methods.\n */\nvar AuthHttpRequest = /** @class */function () {\n  function AuthHttpRequest() {}\n  AuthHttpRequest.init = function (config, recipeImpl) {\n    (0, logger_1.logDebugMessage)(\"init: called\");\n    (0, logger_1.logDebugMessage)(\"init: Input apiBasePath: \" + config.apiBasePath);\n    (0, logger_1.logDebugMessage)(\"init: Input apiDomain: \" + config.apiDomain);\n    (0, logger_1.logDebugMessage)(\"init: Input autoAddCredentials: \" + config.autoAddCredentials);\n    (0, logger_1.logDebugMessage)(\"init: Input cookieDomain: \" + config.cookieDomain);\n    (0, logger_1.logDebugMessage)(\"init: Input isInIframe: \" + config.isInIframe);\n    (0, logger_1.logDebugMessage)(\"init: Input sessionExpiredStatusCode: \" + config.sessionExpiredStatusCode);\n    (0, logger_1.logDebugMessage)(\"init: Input sessionScope: \" + config.sessionScope);\n    AuthHttpRequest.env = getWindowOrThrow().fetch === undefined ? global : getWindowOrThrow();\n    AuthHttpRequest.refreshTokenUrl = config.apiDomain + config.apiBasePath + \"/session/refresh\";\n    AuthHttpRequest.signOutUrl = config.apiDomain + config.apiBasePath + \"/signout\";\n    AuthHttpRequest.rid = \"session\";\n    AuthHttpRequest.config = config;\n    if (AuthHttpRequest.env.__supertokensOriginalFetch === undefined) {\n      (0, logger_1.logDebugMessage)(\"init: __supertokensOriginalFetch is undefined\");\n      // this block contains code that is run just once per page load..\n      // all items in this block are attached to the global env so that\n      // even if the init function is called more than once (maybe across JS scripts),\n      // things will not get created multiple times.\n      AuthHttpRequest.env.__supertokensOriginalFetch = AuthHttpRequest.env.fetch.bind(AuthHttpRequest.env);\n      AuthHttpRequest.env.__supertokensSessionRecipe = recipeImpl;\n      AuthHttpRequest.env.fetch = AuthHttpRequest.env.__supertokensSessionRecipe.addFetchInterceptorsAndReturnModifiedFetch({\n        originalFetch: AuthHttpRequest.env.__supertokensOriginalFetch,\n        userContext: {}\n      });\n      AuthHttpRequest.env.__supertokensSessionRecipe.addXMLHttpRequestInterceptor({\n        userContext: {}\n      });\n    }\n    AuthHttpRequest.recipeImpl = AuthHttpRequest.env.__supertokensSessionRecipe;\n    AuthHttpRequest.initCalled = true;\n  };\n  var _a;\n  _a = AuthHttpRequest;\n  AuthHttpRequest.initCalled = false;\n  AuthHttpRequest.doRequest = function (httpCall, config, url) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var doNotDoInterception, returnObj, preRequestIdToken, clonedHeaders, configWithAntiCsrf, antiCsrfToken, response, idRefreshToken, retry, antiCsrfToken, tok, frontToken, postRequestIdToken;\n      return __generator(_a, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!AuthHttpRequest.initCalled) {\n              throw Error(\"init function not called\");\n            }\n            (0, logger_1.logDebugMessage)(\"doRequest: start of fetch interception\");\n            doNotDoInterception = false;\n            try {\n              doNotDoInterception = typeof url === \"string\" && !(0, utils_1.shouldDoInterceptionBasedOnUrl)(url, AuthHttpRequest.config.apiDomain, AuthHttpRequest.config.cookieDomain) || url !== undefined && typeof url.url === \"string\" &&\n              // this is because url can be an object like {method: ..., url: ...}\n              !(0, utils_1.shouldDoInterceptionBasedOnUrl)(url.url, AuthHttpRequest.config.apiDomain, AuthHttpRequest.config.cookieDomain);\n            } catch (err) {\n              if (err.message === \"Please provide a valid domain name\") {\n                (0, logger_1.logDebugMessage)(\"doRequest: Trying shouldDoInterceptionBasedOnUrl with location.origin\");\n                // .origin gives the port as well..\n                doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(), AuthHttpRequest.config.apiDomain, AuthHttpRequest.config.cookieDomain);\n              } else {\n                throw err;\n              }\n            }\n            (0, logger_1.logDebugMessage)(\"doRequest: Value of doNotDoInterception: \" + doNotDoInterception);\n            if (!doNotDoInterception) return [3 /*break*/, 2];\n            (0, logger_1.logDebugMessage)(\"doRequest: Returning without interception\");\n            return [4 /*yield*/, httpCall(config)];\n          case 1:\n            return [2 /*return*/, _b.sent()];\n          case 2:\n            (0, logger_1.logDebugMessage)(\"doRequest: Interception started\");\n            processState_1.ProcessState.getInstance().addState(processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST);\n            _b.label = 3;\n          case 3:\n            _b.trys.push([3,, 22, 27]);\n            returnObj = undefined;\n            _b.label = 4;\n          case 4:\n            if (!true) return [3 /*break*/, 21];\n            return [4 /*yield*/, getIdRefreshToken(true)];\n          case 5:\n            preRequestIdToken = _b.sent();\n            clonedHeaders = new Headers(config !== undefined && config.headers !== undefined ? config.headers : url.headers);\n            configWithAntiCsrf = __assign(__assign({}, config), {\n              headers: clonedHeaders\n            });\n            if (!(preRequestIdToken.status === \"EXISTS\")) return [3 /*break*/, 7];\n            return [4 /*yield*/, AntiCsrfToken.getToken(preRequestIdToken.token)];\n          case 6:\n            antiCsrfToken = _b.sent();\n            if (antiCsrfToken !== undefined) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Adding anti-csrf token to request\");\n              clonedHeaders.set(\"anti-csrf\", antiCsrfToken);\n            }\n            _b.label = 7;\n          case 7:\n            if (AuthHttpRequest.config.autoAddCredentials) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Adding credentials include\");\n              if (configWithAntiCsrf === undefined) {\n                configWithAntiCsrf = {\n                  credentials: \"include\"\n                };\n              } else if (configWithAntiCsrf.credentials === undefined) {\n                configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                  credentials: \"include\"\n                });\n              }\n            }\n            // adding rid for anti-csrf protection: Anti-csrf via custom header\n            if (!clonedHeaders.has(\"rid\")) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Adding rid header: anti-csrf\");\n              clonedHeaders.set(\"rid\", \"anti-csrf\");\n            } else {\n              (0, logger_1.logDebugMessage)(\"doRequest: rid header was already there in request\");\n            }\n            (0, logger_1.logDebugMessage)(\"doRequest: Making user's http call\");\n            return [4 /*yield*/, httpCall(configWithAntiCsrf)];\n          case 8:\n            response = _b.sent();\n            (0, logger_1.logDebugMessage)(\"doRequest: User's http call ended\");\n            idRefreshToken = response.headers.get(\"id-refresh-token\");\n            if (!idRefreshToken) return [3 /*break*/, 10];\n            (0, logger_1.logDebugMessage)(\"doRequest: Setting sIRTFrontend: \" + idRefreshToken);\n            return [4 /*yield*/, setIdRefreshToken(idRefreshToken, response.status)];\n          case 9:\n            _b.sent();\n            _b.label = 10;\n          case 10:\n            if (!(response.status === AuthHttpRequest.config.sessionExpiredStatusCode)) return [3 /*break*/, 12];\n            (0, logger_1.logDebugMessage)(\"doRequest: Status code is: \" + response.status);\n            return [4 /*yield*/, onUnauthorisedResponse(preRequestIdToken)];\n          case 11:\n            retry = _b.sent();\n            if (retry.result !== \"RETRY\") {\n              (0, logger_1.logDebugMessage)(\"doRequest: Not retrying original request\");\n              returnObj = retry.error !== undefined ? retry.error : response;\n              return [3 /*break*/, 21];\n            }\n            (0, logger_1.logDebugMessage)(\"doRequest: Retrying original request\");\n            return [3 /*break*/, 20];\n          case 12:\n            if (!(response.status === AuthHttpRequest.config.invalidClaimStatusCode)) return [3 /*break*/, 14];\n            return [4 /*yield*/, onInvalidClaimResponse(response)];\n          case 13:\n            _b.sent();\n            _b.label = 14;\n          case 14:\n            antiCsrfToken = response.headers.get(\"anti-csrf\");\n            if (!antiCsrfToken) return [3 /*break*/, 17];\n            return [4 /*yield*/, getIdRefreshToken(true)];\n          case 15:\n            tok = _b.sent();\n            if (!(tok.status === \"EXISTS\")) return [3 /*break*/, 17];\n            (0, logger_1.logDebugMessage)(\"doRequest: Setting anti-csrf token\");\n            return [4 /*yield*/, AntiCsrfToken.setItem(tok.token, antiCsrfToken)];\n          case 16:\n            _b.sent();\n            _b.label = 17;\n          case 17:\n            frontToken = response.headers.get(\"front-token\");\n            if (!frontToken) return [3 /*break*/, 19];\n            (0, logger_1.logDebugMessage)(\"doRequest: Setting sFrontToken: \" + frontToken);\n            return [4 /*yield*/, FrontToken.setItem(frontToken)];\n          case 18:\n            _b.sent();\n            _b.label = 19;\n          case 19:\n            return [2 /*return*/, response];\n          case 20:\n            return [3 /*break*/, 4];\n          case 21:\n            // if it comes here, means we breaked. which happens only if we have logged out.\n            return [2 /*return*/, returnObj];\n          case 22:\n            return [4 /*yield*/, getIdRefreshToken(false)];\n          case 23:\n            postRequestIdToken = _b.sent();\n            if (!(postRequestIdToken.status === \"NOT_EXISTS\")) return [3 /*break*/, 26];\n            (0, logger_1.logDebugMessage)(\"doRequest: sIRTFrontend doesn't exist, so removing anti-csrf and sFrontToken\");\n            return [4 /*yield*/, AntiCsrfToken.removeToken()];\n          case 24:\n            _b.sent();\n            return [4 /*yield*/, FrontToken.removeToken()];\n          case 25:\n            _b.sent();\n            _b.label = 26;\n          case 26:\n            return [7 /*endfinally*/];\n          case 27:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  AuthHttpRequest.attemptRefreshingSession = function () {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var preRequestIdToken, refresh;\n      return __generator(_a, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!AuthHttpRequest.initCalled) {\n              throw Error(\"init function not called\");\n            }\n            return [4 /*yield*/, getIdRefreshToken(false)];\n          case 1:\n            preRequestIdToken = _b.sent();\n            return [4 /*yield*/, onUnauthorisedResponse(preRequestIdToken)];\n          case 2:\n            refresh = _b.sent();\n            if (refresh.result === \"API_ERROR\") {\n              throw refresh.error;\n            }\n            return [2 /*return*/, refresh.result === \"RETRY\"];\n        }\n      });\n    });\n  };\n  return AuthHttpRequest;\n}();\nexports.default = AuthHttpRequest;\nvar ID_REFRESH_TOKEN_NAME = \"sIRTFrontend\";\nvar ANTI_CSRF_NAME = \"sAntiCsrf\";\nvar FRONT_TOKEN_NAME = \"sFrontToken\";\n/**\n * @description attempts to call the refresh token API each time we are sure the session has expired, or it throws an error or,\n * or the ID_COOKIE_NAME has changed value -> which may mean that we have a new set of tokens.\n */\nfunction onUnauthorisedResponse(preRequestIdToken) {\n  return __awaiter(this, void 0, void 0, function () {\n    var lock, postLockID, headers, antiCsrfToken_1, preAPIResult, response, removeIdRefreshToken, idRefreshToken, antiCsrfToken, tok, frontToken, error_1, idCookieValue;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          lock = new browser_tabs_lock_1.default();\n          _b.label = 1;\n        case 1:\n          if (!true) return [3 /*break*/, 30];\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: trying to acquire lock\");\n          return [4 /*yield*/, lock.acquireLock(\"REFRESH_TOKEN_USE\", 1000)];\n        case 2:\n          if (!_b.sent()) return [3 /*break*/, 28];\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: lock acquired\");\n          _b.label = 3;\n        case 3:\n          _b.trys.push([3, 20, 22, 28]);\n          return [4 /*yield*/, getIdRefreshToken(false)];\n        case 4:\n          postLockID = _b.sent();\n          if (postLockID.status === \"NOT_EXISTS\") {\n            (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Not refreshing because sIRTFrontend is remove\");\n            // if it comes here, it means a request was made thinking\n            // that the session exists, but it doesn't actually exist.\n            AuthHttpRequest.config.onHandleEvent({\n              action: \"UNAUTHORISED\",\n              sessionExpiredOrRevoked: false,\n              userContext: {}\n            });\n            return [2 /*return*/, {\n              result: \"SESSION_EXPIRED\"\n            }];\n          }\n          if (postLockID.status !== preRequestIdToken.status || postLockID.status === \"EXISTS\" && preRequestIdToken.status === \"EXISTS\" && postLockID.token !== preRequestIdToken.token) {\n            (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Retrying early because pre and post id refresh tokens don't match\");\n            // means that some other process has already called this API and succeeded. so we need to call it again\n            return [2 /*return*/, {\n              result: \"RETRY\"\n            }];\n          }\n          headers = {};\n          if (!(preRequestIdToken.status === \"EXISTS\")) return [3 /*break*/, 6];\n          return [4 /*yield*/, AntiCsrfToken.getToken(preRequestIdToken.token)];\n        case 5:\n          antiCsrfToken_1 = _b.sent();\n          if (antiCsrfToken_1 !== undefined) {\n            (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Adding anti-csrf token to refresh API call\");\n            headers = __assign(__assign({}, headers), {\n              \"anti-csrf\": antiCsrfToken_1\n            });\n          }\n          _b.label = 6;\n        case 6:\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Adding rid and fdi-versions to refresh call header\");\n          headers = __assign(__assign({\n            rid: AuthHttpRequest.rid\n          }, headers), {\n            \"fdi-version\": version_1.supported_fdi.join(\",\")\n          });\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Calling refresh pre API hook\");\n          return [4 /*yield*/, AuthHttpRequest.config.preAPIHook({\n            action: \"REFRESH_SESSION\",\n            requestInit: {\n              method: \"post\",\n              credentials: \"include\",\n              headers: headers\n            },\n            url: AuthHttpRequest.refreshTokenUrl,\n            userContext: {}\n          })];\n        case 7:\n          preAPIResult = _b.sent();\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Making refresh call\");\n          return [4 /*yield*/, AuthHttpRequest.env.__supertokensOriginalFetch(preAPIResult.url, preAPIResult.requestInit)];\n        case 8:\n          response = _b.sent();\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Refresh call ended\");\n          removeIdRefreshToken = true;\n          idRefreshToken = response.headers.get(\"id-refresh-token\");\n          if (!idRefreshToken) return [3 /*break*/, 10];\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Setting sIRTFrontend from refresh API call: \" + idRefreshToken);\n          return [4 /*yield*/, setIdRefreshToken(idRefreshToken, response.status)];\n        case 9:\n          _b.sent();\n          removeIdRefreshToken = false;\n          _b.label = 10;\n        case 10:\n          if (!(response.status === AuthHttpRequest.config.sessionExpiredStatusCode)) return [3 /*break*/, 12];\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Refresh status code is: \" + response.status);\n          if (!removeIdRefreshToken) return [3 /*break*/, 12];\n          return [4 /*yield*/, setIdRefreshToken(\"remove\", response.status)];\n        case 11:\n          _b.sent();\n          _b.label = 12;\n        case 12:\n          if (response.status >= 300) {\n            throw response;\n          }\n          return [4 /*yield*/, AuthHttpRequest.config.postAPIHook({\n            action: \"REFRESH_SESSION\",\n            fetchResponse: response.clone(),\n            requestInit: preAPIResult.requestInit,\n            url: preAPIResult.url,\n            userContext: {}\n          })];\n        case 13:\n          _b.sent();\n          return [4 /*yield*/, getIdRefreshToken(false)];\n        case 14:\n          if (_b.sent().status === \"NOT_EXISTS\") {\n            (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: sIRTFrontend is remove, so returning session expired\");\n            // The execution should never come here.. but just in case.\n            // removed by server. So we logout\n            // we do not send \"UNAUTHORISED\" event here because\n            // this is a result of the refresh API returning a session expiry, which\n            // means that the frontend did not know for sure that the session existed\n            // in the first place.\n            return [2 /*return*/, {\n              result: \"SESSION_EXPIRED\"\n            }];\n          }\n          antiCsrfToken = response.headers.get(\"anti-csrf\");\n          if (!antiCsrfToken) return [3 /*break*/, 17];\n          return [4 /*yield*/, getIdRefreshToken(true)];\n        case 15:\n          tok = _b.sent();\n          if (!(tok.status === \"EXISTS\")) return [3 /*break*/, 17];\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: setting anti-csrf token\");\n          return [4 /*yield*/, AntiCsrfToken.setItem(tok.token, antiCsrfToken)];\n        case 16:\n          _b.sent();\n          _b.label = 17;\n        case 17:\n          frontToken = response.headers.get(\"front-token\");\n          if (!frontToken) return [3 /*break*/, 19];\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: setting sFrontToken: \" + frontToken);\n          return [4 /*yield*/, FrontToken.setItem(frontToken)];\n        case 18:\n          _b.sent();\n          _b.label = 19;\n        case 19:\n          AuthHttpRequest.config.onHandleEvent({\n            action: \"REFRESH_SESSION\",\n            userContext: {}\n          });\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Sending RETRY signal\");\n          return [2 /*return*/, {\n            result: \"RETRY\"\n          }];\n        case 20:\n          error_1 = _b.sent();\n          return [4 /*yield*/, getIdRefreshToken(false)];\n        case 21:\n          if (_b.sent().status === \"NOT_EXISTS\") {\n            (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: sIRTFrontend is remove, so returning session expired\");\n            // removed by server.\n            // we do not send \"UNAUTHORISED\" event here because\n            // this is a result of the refresh API returning a session expiry, which\n            // means that the frontend did not know for sure that the session existed\n            // in the first place.\n            return [2 /*return*/, {\n              result: \"SESSION_EXPIRED\",\n              error: error_1\n            }];\n          }\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: sending API_ERROR\");\n          return [2 /*return*/, {\n            result: \"API_ERROR\",\n            error: error_1\n          }];\n        case 22:\n          return [4 /*yield*/, lock.releaseLock(\"REFRESH_TOKEN_USE\")];\n        case 23:\n          _b.sent();\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Released lock\");\n          return [4 /*yield*/, getIdRefreshToken(false)];\n        case 24:\n          if (!(_b.sent().status === \"NOT_EXISTS\")) return [3 /*break*/, 27];\n          (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: sIRTFrontend is remove, so removing anti-csrf and sFrontToken\");\n          return [4 /*yield*/, AntiCsrfToken.removeToken()];\n        case 25:\n          _b.sent();\n          return [4 /*yield*/, FrontToken.removeToken()];\n        case 26:\n          _b.sent();\n          _b.label = 27;\n        case 27:\n          return [7 /*endfinally*/];\n        case 28:\n          return [4 /*yield*/, getIdRefreshToken(false)];\n        case 29:\n          idCookieValue = _b.sent();\n          if (idCookieValue.status === \"NOT_EXISTS\") {\n            (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: lock acquired failed and sIRTFrontend is remove, so sending SESSION_EXPIRED\");\n            // removed by server. So we logout\n            return [2 /*return*/, {\n              result: \"SESSION_EXPIRED\"\n            }];\n          } else {\n            if (idCookieValue.status !== preRequestIdToken.status || idCookieValue.status === \"EXISTS\" && preRequestIdToken.status === \"EXISTS\" && idCookieValue.token !== preRequestIdToken.token) {\n              (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: lock acquired failed and retrying early because pre and post id refresh tokens don't match\");\n              return [2 /*return*/, {\n                result: \"RETRY\"\n              }];\n            }\n            // here we try to call the API again since we probably failed to acquire lock and nothing has changed.\n          }\n\n          return [3 /*break*/, 1];\n        case 30:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexports.onUnauthorisedResponse = onUnauthorisedResponse;\nfunction onTokenUpdate() {\n  (0, logger_1.logDebugMessage)(\"onTokenUpdate: firing ACCESS_TOKEN_PAYLOAD_UPDATED event\");\n  AuthHttpRequest.config.onHandleEvent({\n    action: \"ACCESS_TOKEN_PAYLOAD_UPDATED\",\n    userContext: {}\n  });\n}\nexports.onTokenUpdate = onTokenUpdate;\nfunction onInvalidClaimResponse(response) {\n  return __awaiter(this, void 0, void 0, function () {\n    var claimValidationErrors, _b;\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          _c.trys.push([0, 2,, 3]);\n          return [4 /*yield*/, AuthHttpRequest.recipeImpl.getInvalidClaimsFromResponse({\n            response: response,\n            userContext: {}\n          })];\n        case 1:\n          claimValidationErrors = _c.sent();\n          // This shouldn't be undefined normally, but since we can't be certain about the shape of the response object so we check it like this.\n          // It could still be something else, but chance of that happening by accident is really low.\n          if (claimValidationErrors) {\n            AuthHttpRequest.config.onHandleEvent({\n              action: \"API_INVALID_CLAIM\",\n              claimValidationErrors: claimValidationErrors,\n              userContext: {}\n            });\n          }\n          return [3 /*break*/, 3];\n        case 2:\n          _b = _c.sent();\n          return [3 /*break*/, 3];\n        case 3:\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexports.onInvalidClaimResponse = onInvalidClaimResponse;\n// if tryRefresh is true & this token doesn't exist, we try and refresh the session\n// else we return undefined.\nfunction getIdRefreshToken(tryRefresh) {\n  return __awaiter(this, void 0, void 0, function () {\n    function getIdRefreshTokenFromLocal() {\n      return __awaiter(this, void 0, void 0, function () {\n        function getIDFromCookieOld() {\n          return __awaiter(this, void 0, void 0, function () {\n            var value, _b, parts, last;\n            return __generator(this, function (_c) {\n              switch (_c.label) {\n                case 0:\n                  _b = \"; \";\n                  return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.getCookie()];\n                case 1:\n                  value = _b + _c.sent();\n                  parts = value.split(\"; \" + ID_REFRESH_TOKEN_NAME + \"=\");\n                  if (parts.length >= 2) {\n                    last = parts.pop();\n                    if (last === \"remove\") {\n                      // it means no session exists. This is different from\n                      // it being undefined since in that case a session may or may not exist.\n                      return [2 /*return*/, \"remove\"];\n                    }\n                    if (last !== undefined) {\n                      return [2 /*return*/, last.split(\";\").shift()];\n                    }\n                  }\n                  return [2 /*return*/, undefined];\n              }\n            });\n          });\n        }\n        var fromCookie;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              return [4 /*yield*/, getIDFromCookieOld()];\n            case 1:\n              fromCookie = _b.sent();\n              return [2 /*return*/, fromCookie];\n          }\n        });\n      });\n    }\n    var token, response, res;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"getIdRefreshToken: called\");\n          return [4 /*yield*/, getIdRefreshTokenFromLocal()];\n        case 1:\n          token = _b.sent();\n          if (token === \"remove\") {\n            (0, logger_1.logDebugMessage)(\"getIdRefreshToken: is removed\");\n            return [2 /*return*/, {\n              status: \"NOT_EXISTS\"\n            }];\n          }\n          if (!(token === undefined)) return [3 /*break*/, 5];\n          (0, logger_1.logDebugMessage)(\"getIdRefreshToken: is undefined\");\n          response = {\n            status: \"MAY_EXIST\"\n          };\n          if (!tryRefresh) return [3 /*break*/, 4];\n          (0, logger_1.logDebugMessage)(\"getIdRefreshToken: trying to refresg\");\n          return [4 /*yield*/, onUnauthorisedResponse(response)];\n        case 2:\n          res = _b.sent();\n          if (res.result !== \"RETRY\") {\n            (0, logger_1.logDebugMessage)(\"getIdRefreshToken: false NOT_EXISTS in case error from backend\");\n            // in case the backend is not working, we treat it as the session not existing...\n            return [2 /*return*/, {\n              status: \"NOT_EXISTS\"\n            }];\n          }\n          (0, logger_1.logDebugMessage)(\"getIdRefreshToken: Retrying post refresh\");\n          return [4 /*yield*/, getIdRefreshToken(tryRefresh)];\n        case 3:\n          return [2 /*return*/, _b.sent()];\n        case 4:\n          (0, logger_1.logDebugMessage)(\"getIdRefreshToken: returning: \" + response.status);\n          return [2 /*return*/, response];\n        case 5:\n          (0, logger_1.logDebugMessage)(\"getIdRefreshToken: returning EXISTS: \" + token);\n          return [2 /*return*/, {\n            status: \"EXISTS\",\n            token: token\n          }];\n      }\n    });\n  });\n}\nexports.getIdRefreshToken = getIdRefreshToken;\nfunction setIdRefreshToken(idRefreshToken, statusCode) {\n  return __awaiter(this, void 0, void 0, function () {\n    function setIDToCookie(idRefreshToken, domain) {\n      return __awaiter(this, void 0, void 0, function () {\n        var expires, cookieVal, splitted;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              expires = \"Fri, 31 Dec 9999 23:59:59 GMT\";\n              cookieVal = \"remove\";\n              if (idRefreshToken !== \"remove\") {\n                splitted = idRefreshToken.split(\";\");\n                cookieVal = splitted[0];\n                // we must always respect this expiry and not set it to infinite\n                // cause this ties into the session's lifetime. If we set this\n                // to infinite, then a session may not exist, and this will exist,\n                // then for example, if we check a session exists, and this says yes,\n                // then if we getAccessTokenPayload, that will attempt a session refresh which will fail.\n                // Another reason to respect this is that if we don't, then signOut will\n                // call the API which will return 200 (no 401 cause the API thinks no session exists),\n                // in which case, we will not end up firing the SIGN_OUT on handle event.\n                expires = new Date(Number(splitted[1])).toUTCString();\n              }\n              if (!(domain === \"localhost\" || domain === windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getHostName())) return [3 /*break*/, 2];\n              // since some browsers ignore cookies with domain set to localhost\n              // see https://github.com/supertokens/supertokens-website/issues/25\n              return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(ID_REFRESH_TOKEN_NAME, \"=\").concat(cookieVal, \";expires=\").concat(expires, \";path=/;samesite=\").concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\"))];\n            case 1:\n              // since some browsers ignore cookies with domain set to localhost\n              // see https://github.com/supertokens/supertokens-website/issues/25\n              _b.sent();\n              return [3 /*break*/, 4];\n            case 2:\n              return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(ID_REFRESH_TOKEN_NAME, \"=\").concat(cookieVal, \";expires=\").concat(expires, \";domain=\").concat(domain, \";path=/;samesite=\").concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\"))];\n            case 3:\n              _b.sent();\n              _b.label = 4;\n            case 4:\n              return [2 /*return*/];\n          }\n        });\n      });\n    }\n\n    var status;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"setIdRefreshToken: called\");\n          return [4 /*yield*/, getIdRefreshToken(false)];\n        case 1:\n          status = _b.sent().status;\n          (0, logger_1.logDebugMessage)(\"setIdRefreshToken: setting: \" + idRefreshToken);\n          return [4 /*yield*/, setIDToCookie(idRefreshToken, AuthHttpRequest.config.sessionScope)];\n        case 2:\n          _b.sent();\n          if (idRefreshToken === \"remove\" && status === \"EXISTS\") {\n            // we check for wasLoggedIn cause we don't want to fire an event\n            // unnecessarily on first app load or if the user tried\n            // to query an API that returned 401 while the user was not logged in...\n            if (statusCode === AuthHttpRequest.config.sessionExpiredStatusCode) {\n              (0, logger_1.logDebugMessage)(\"setIdRefreshToken: firing UNAUTHORISED event\");\n              AuthHttpRequest.config.onHandleEvent({\n                action: \"UNAUTHORISED\",\n                sessionExpiredOrRevoked: true,\n                userContext: {}\n              });\n            } else {\n              (0, logger_1.logDebugMessage)(\"setIdRefreshToken: firing SIGN_OUT event\");\n              AuthHttpRequest.config.onHandleEvent({\n                action: \"SIGN_OUT\",\n                userContext: {}\n              });\n            }\n          }\n          if (idRefreshToken !== \"remove\" && status === \"NOT_EXISTS\") {\n            (0, logger_1.logDebugMessage)(\"setIdRefreshToken: firing SESSION_CREATED event\");\n            AuthHttpRequest.config.onHandleEvent({\n              action: \"SESSION_CREATED\",\n              userContext: {}\n            });\n          }\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexports.setIdRefreshToken = setIdRefreshToken;\nfunction getAntiCSRFToken() {\n  return __awaiter(this, void 0, void 0, function () {\n    function getAntiCSRFromCookie() {\n      return __awaiter(this, void 0, void 0, function () {\n        var value, _b, parts, last, temp;\n        return __generator(this, function (_c) {\n          switch (_c.label) {\n            case 0:\n              _b = \"; \";\n              return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.getCookie()];\n            case 1:\n              value = _b + _c.sent();\n              parts = value.split(\"; \" + ANTI_CSRF_NAME + \"=\");\n              if (parts.length >= 2) {\n                last = parts.pop();\n                if (last !== undefined) {\n                  temp = last.split(\";\").shift();\n                  if (temp === undefined) {\n                    return [2 /*return*/, null];\n                  }\n                  return [2 /*return*/, temp];\n                }\n              }\n              return [2 /*return*/, null];\n          }\n        });\n      });\n    }\n    var fromCookie;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"getAntiCSRFToken: called\");\n          return [4 /*yield*/, getIdRefreshToken(true)];\n        case 1:\n          // we do not call doesSessionExist here cause the user might override that\n          // function here and then it may break the logic of our original implementation.\n          if (!(_b.sent().status === \"EXISTS\")) {\n            (0, logger_1.logDebugMessage)(\"getAntiCSRFToken: Returning because sIRTFrontend != EXISTS\");\n            return [2 /*return*/, null];\n          }\n          return [4 /*yield*/, getAntiCSRFromCookie()];\n        case 2:\n          fromCookie = _b.sent();\n          (0, logger_1.logDebugMessage)(\"getAntiCSRFToken: returning: \" + fromCookie);\n          return [2 /*return*/, fromCookie];\n      }\n    });\n  });\n}\n// give antiCSRFToken as undefined to remove it.\nfunction setAntiCSRF(antiCSRFToken) {\n  return __awaiter(this, void 0, void 0, function () {\n    function setAntiCSRFToCookie(antiCSRFToken, domain) {\n      return __awaiter(this, void 0, void 0, function () {\n        var expires, cookieVal;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              expires = \"Thu, 01 Jan 1970 00:00:01 GMT\";\n              cookieVal = \"\";\n              if (antiCSRFToken !== undefined) {\n                cookieVal = antiCSRFToken;\n                expires = undefined; // set cookie without expiry\n              }\n\n              if (!(domain === \"localhost\" || domain === windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getHostName())) return [3 /*break*/, 5];\n              if (!(expires !== undefined)) return [3 /*break*/, 2];\n              return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(ANTI_CSRF_NAME, \"=\").concat(cookieVal, \";expires=\").concat(expires, \";path=/;samesite=\").concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\"))];\n            case 1:\n              _b.sent();\n              return [3 /*break*/, 4];\n            case 2:\n              return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(ANTI_CSRF_NAME, \"=\").concat(cookieVal, \";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=\").concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\"))];\n            case 3:\n              _b.sent();\n              _b.label = 4;\n            case 4:\n              return [3 /*break*/, 9];\n            case 5:\n              if (!(expires !== undefined)) return [3 /*break*/, 7];\n              return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(ANTI_CSRF_NAME, \"=\").concat(cookieVal, \";expires=\").concat(expires, \";domain=\").concat(domain, \";path=/;samesite=\").concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\"))];\n            case 6:\n              _b.sent();\n              return [3 /*break*/, 9];\n            case 7:\n              return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(ANTI_CSRF_NAME, \"=\").concat(cookieVal, \";domain=\").concat(domain, \";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=\").concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\"))];\n            case 8:\n              _b.sent();\n              _b.label = 9;\n            case 9:\n              return [2 /*return*/];\n          }\n        });\n      });\n    }\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"setAntiCSRF: called: \" + antiCSRFToken);\n          return [4 /*yield*/, setAntiCSRFToCookie(antiCSRFToken, AuthHttpRequest.config.sessionScope)];\n        case 1:\n          _b.sent();\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexports.setAntiCSRF = setAntiCSRF;\nfunction getFrontTokenFromCookie() {\n  return __awaiter(this, void 0, void 0, function () {\n    var value, _b, parts, last, temp;\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"getFrontTokenFromCookie: called\");\n          _b = \"; \";\n          return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.getCookie()];\n        case 1:\n          value = _b + _c.sent();\n          parts = value.split(\"; \" + FRONT_TOKEN_NAME + \"=\");\n          if (parts.length >= 2) {\n            last = parts.pop();\n            if (last !== undefined) {\n              temp = last.split(\";\").shift();\n              if (temp === undefined) {\n                return [2 /*return*/, null];\n              }\n              return [2 /*return*/, temp];\n            }\n          }\n          return [2 /*return*/, null];\n      }\n    });\n  });\n}\nfunction parseFrontToken(frontToken) {\n  return JSON.parse(decodeURIComponent(escape(atob(frontToken))));\n}\nfunction getFrontToken() {\n  return __awaiter(this, void 0, void 0, function () {\n    var fromCookie;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"getFrontToken: called\");\n          return [4 /*yield*/, getIdRefreshToken(true)];\n        case 1:\n          // we do not call doesSessionExist here cause the user might override that\n          // function here and then it may break the logic of our original implementation.\n          if (!(_b.sent().status === \"EXISTS\")) {\n            (0, logger_1.logDebugMessage)(\"getFrontToken: Returning because sIRTFrontend != EXISTS\");\n            return [2 /*return*/, null];\n          }\n          return [4 /*yield*/, getFrontTokenFromCookie()];\n        case 2:\n          fromCookie = _b.sent();\n          (0, logger_1.logDebugMessage)(\"getFrontToken: returning: \" + fromCookie);\n          return [2 /*return*/, fromCookie];\n      }\n    });\n  });\n}\nexports.getFrontToken = getFrontToken;\nfunction setFrontToken(frontToken) {\n  return __awaiter(this, void 0, void 0, function () {\n    function setFrontTokenToCookie(frontToken, domain) {\n      return __awaiter(this, void 0, void 0, function () {\n        var expires, cookieVal;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              expires = \"Thu, 01 Jan 1970 00:00:01 GMT\";\n              cookieVal = \"\";\n              if (frontToken !== undefined) {\n                cookieVal = frontToken;\n                expires = undefined; // set cookie without expiry\n              }\n\n              if (!(domain === \"localhost\" || domain === windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getHostName())) return [3 /*break*/, 5];\n              if (!(expires !== undefined)) return [3 /*break*/, 2];\n              return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(FRONT_TOKEN_NAME, \"=\").concat(cookieVal, \";expires=\").concat(expires, \";path=/;samesite=\").concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\"))];\n            case 1:\n              _b.sent();\n              return [3 /*break*/, 4];\n            case 2:\n              return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(FRONT_TOKEN_NAME, \"=\").concat(cookieVal, \";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=\").concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\"))];\n            case 3:\n              _b.sent();\n              _b.label = 4;\n            case 4:\n              return [3 /*break*/, 9];\n            case 5:\n              if (!(expires !== undefined)) return [3 /*break*/, 7];\n              return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(FRONT_TOKEN_NAME, \"=\").concat(cookieVal, \";expires=\").concat(expires, \";domain=\").concat(domain, \";path=/;samesite=\").concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\"))];\n            case 6:\n              _b.sent();\n              return [3 /*break*/, 9];\n            case 7:\n              return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\"\".concat(FRONT_TOKEN_NAME, \"=\").concat(cookieVal, \";domain=\").concat(domain, \";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=\").concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\"))];\n            case 8:\n              _b.sent();\n              _b.label = 9;\n            case 9:\n              return [2 /*return*/];\n          }\n        });\n      });\n    }\n\n    var oldToken, oldPayload, newPayload;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"setFrontToken: called\");\n          return [4 /*yield*/, getFrontTokenFromCookie()];\n        case 1:\n          oldToken = _b.sent();\n          if (oldToken !== null && frontToken !== undefined) {\n            oldPayload = parseFrontToken(oldToken).up;\n            newPayload = parseFrontToken(frontToken).up;\n            if (JSON.stringify(oldPayload) !== JSON.stringify(newPayload)) {\n              onTokenUpdate();\n            }\n          }\n          return [4 /*yield*/, setFrontTokenToCookie(frontToken, AuthHttpRequest.config.sessionScope)];\n        case 2:\n          _b.sent();\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nexports.setFrontToken = setFrontToken;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","__generator","body","_","label","sent","trys","ops","f","y","g","verb","throw","return","Symbol","iterator","v","op","TypeError","pop","push","defineProperty","exports","setFrontToken","getFrontToken","setAntiCSRF","setIdRefreshToken","getIdRefreshToken","onInvalidClaimResponse","onTokenUpdate","onUnauthorisedResponse","FrontToken","AntiCsrfToken","processState_1","require","version_1","browser_tabs_lock_1","utils_1","cookieHandler_1","windowHandler_1","logger_1","getWindowOrThrow","window","Error","getToken","associatedIdRefreshToken","antiCsrf","_a","logDebugMessage","undefined","tokenInfo","getAntiCSRFToken","removeToken","setItem","getTokenInfo","frontToken","response","status","waiters","parseFrontToken","ate","uid","up","forEach","AuthHttpRequest","init","config","recipeImpl","apiBasePath","apiDomain","autoAddCredentials","cookieDomain","isInIframe","sessionExpiredStatusCode","sessionScope","env","fetch","global","refreshTokenUrl","signOutUrl","rid","__supertokensOriginalFetch","bind","__supertokensSessionRecipe","addFetchInterceptorsAndReturnModifiedFetch","originalFetch","userContext","addXMLHttpRequestInterceptor","initCalled","doRequest","httpCall","url","doNotDoInterception","returnObj","preRequestIdToken","clonedHeaders","configWithAntiCsrf","antiCsrfToken","idRefreshToken","retry","tok","postRequestIdToken","_b","shouldDoInterceptionBasedOnUrl","err","message","default","getReferenceOrThrow","windowHandler","location","getOrigin","ProcessState","getInstance","addState","PROCESS_STATE","CALLING_INTERCEPTION_REQUEST","Headers","headers","token","set","credentials","has","get","error","invalidClaimStatusCode","attemptRefreshingSession","refresh","ID_REFRESH_TOKEN_NAME","ANTI_CSRF_NAME","FRONT_TOKEN_NAME","lock","postLockID","antiCsrfToken_1","preAPIResult","removeIdRefreshToken","error_1","idCookieValue","acquireLock","onHandleEvent","action","sessionExpiredOrRevoked","supported_fdi","join","preAPIHook","requestInit","method","postAPIHook","fetchResponse","clone","releaseLock","claimValidationErrors","_c","getInvalidClaimsFromResponse","tryRefresh","getIdRefreshTokenFromLocal","getIDFromCookieOld","parts","last","cookieHandler","getCookie","split","shift","fromCookie","res","statusCode","setIDToCookie","domain","expires","cookieVal","splitted","Date","Number","toUTCString","getHostName","setCookie","concat","getAntiCSRFromCookie","temp","antiCSRFToken","setAntiCSRFToCookie","getFrontTokenFromCookie","JSON","parse","decodeURIComponent","escape","atob","setFrontTokenToCookie","oldToken","oldPayload","newPayload","stringify"],"sources":["C:/Users/jsierra/puntodelaguaapp/frontend/node_modules/supertokens-website/lib/build/fetch.js"],"sourcesContent":["\"use strict\";\nvar __assign =\n    (this && this.__assign) ||\n    function() {\n        __assign =\n            Object.assign ||\n            function(t) {\n                for (var s, i = 1, n = arguments.length; i < n; i++) {\n                    s = arguments[i];\n                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n                }\n                return t;\n            };\n        return __assign.apply(this, arguments);\n    };\nvar __awaiter =\n    (this && this.__awaiter) ||\n    function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n            return value instanceof P\n                ? value\n                : new P(function(resolve) {\n                      resolve(value);\n                  });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n            function fulfilled(value) {\n                try {\n                    step(generator.next(value));\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            function rejected(value) {\n                try {\n                    step(generator[\"throw\"](value));\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n            }\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n    };\nvar __generator =\n    (this && this.__generator) ||\n    function(thisArg, body) {\n        var _ = {\n                label: 0,\n                sent: function() {\n                    if (t[0] & 1) throw t[1];\n                    return t[1];\n                },\n                trys: [],\n                ops: []\n            },\n            f,\n            y,\n            t,\n            g;\n        return (\n            (g = { next: verb(0), throw: verb(1), return: verb(2) }),\n            typeof Symbol === \"function\" &&\n                (g[Symbol.iterator] = function() {\n                    return this;\n                }),\n            g\n        );\n        function verb(n) {\n            return function(v) {\n                return step([n, v]);\n            };\n        }\n        function step(op) {\n            if (f) throw new TypeError(\"Generator is already executing.\");\n            while (_)\n                try {\n                    if (\n                        ((f = 1),\n                        y &&\n                            (t =\n                                op[0] & 2\n                                    ? y[\"return\"]\n                                    : op[0]\n                                    ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0)\n                                    : y.next) &&\n                            !(t = t.call(y, op[1])).done)\n                    )\n                        return t;\n                    if (((y = 0), t)) op = [op[0] & 2, t.value];\n                    switch (op[0]) {\n                        case 0:\n                        case 1:\n                            t = op;\n                            break;\n                        case 4:\n                            _.label++;\n                            return { value: op[1], done: false };\n                        case 5:\n                            _.label++;\n                            y = op[1];\n                            op = [0];\n                            continue;\n                        case 7:\n                            op = _.ops.pop();\n                            _.trys.pop();\n                            continue;\n                        default:\n                            if (\n                                !((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&\n                                (op[0] === 6 || op[0] === 2)\n                            ) {\n                                _ = 0;\n                                continue;\n                            }\n                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {\n                                _.label = op[1];\n                                break;\n                            }\n                            if (op[0] === 6 && _.label < t[1]) {\n                                _.label = t[1];\n                                t = op;\n                                break;\n                            }\n                            if (t && _.label < t[2]) {\n                                _.label = t[2];\n                                _.ops.push(op);\n                                break;\n                            }\n                            if (t[2]) _.ops.pop();\n                            _.trys.pop();\n                            continue;\n                    }\n                    op = body.call(thisArg, _);\n                } catch (e) {\n                    op = [6, e];\n                    y = 0;\n                } finally {\n                    f = t = 0;\n                }\n            if (op[0] & 5) throw op[1];\n            return { value: op[0] ? op[1] : void 0, done: true };\n        }\n    };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setFrontToken = exports.getFrontToken = exports.setAntiCSRF = exports.setIdRefreshToken = exports.getIdRefreshToken = exports.onInvalidClaimResponse = exports.onTokenUpdate = exports.onUnauthorisedResponse = exports.FrontToken = exports.AntiCsrfToken = void 0;\n/* Copyright (c) 2020, VRAI Labs and/or its affiliates. All rights reserved.\n *\n * This software is licensed under the Apache License, Version 2.0 (the\n * \"License\") as published by the Apache Software Foundation.\n *\n * You may not use this file except in compliance with the License. You may\n * obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\nvar processState_1 = require(\"./processState\");\nvar version_1 = require(\"./version\");\nvar browser_tabs_lock_1 = require(\"browser-tabs-lock\");\nvar utils_1 = require(\"./utils\");\nvar cookieHandler_1 = require(\"./utils/cookieHandler\");\nvar windowHandler_1 = require(\"./utils/windowHandler\");\nvar logger_1 = require(\"./logger\");\nfunction getWindowOrThrow() {\n    if (typeof window === \"undefined\") {\n        throw Error(\n            \"If you are using this package with server-side rendering, please make sure that you are checking if the window object is defined.\"\n        );\n    }\n    return window;\n}\nvar AntiCsrfToken = /** @class */ (function() {\n    function AntiCsrfToken() {}\n    AntiCsrfToken.getToken = function(associatedIdRefreshToken) {\n        return __awaiter(this, void 0, void 0, function() {\n            var antiCsrf;\n            return __generator(this, function(_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: called\");\n                        if (associatedIdRefreshToken === undefined) {\n                            AntiCsrfToken.tokenInfo = undefined;\n                            (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: returning undefined\");\n                            return [2 /*return*/, undefined];\n                        }\n                        if (!(AntiCsrfToken.tokenInfo === undefined)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, getAntiCSRFToken()];\n                    case 1:\n                        antiCsrf = _a.sent();\n                        if (antiCsrf === null) {\n                            (0, logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: returning undefined\");\n                            return [2 /*return*/, undefined];\n                        }\n                        AntiCsrfToken.tokenInfo = {\n                            antiCsrf: antiCsrf,\n                            associatedIdRefreshToken: associatedIdRefreshToken\n                        };\n                        return [3 /*break*/, 4];\n                    case 2:\n                        if (!(AntiCsrfToken.tokenInfo.associatedIdRefreshToken !== associatedIdRefreshToken))\n                            return [3 /*break*/, 4];\n                        // csrf token has changed.\n                        AntiCsrfToken.tokenInfo = undefined;\n                        return [4 /*yield*/, AntiCsrfToken.getToken(associatedIdRefreshToken)];\n                    case 3:\n                        return [2 /*return*/, _a.sent()];\n                    case 4:\n                        (0,\n                        logger_1.logDebugMessage)(\"AntiCsrfToken.getToken: returning: \" + AntiCsrfToken.tokenInfo.antiCsrf);\n                        return [2 /*return*/, AntiCsrfToken.tokenInfo.antiCsrf];\n                }\n            });\n        });\n    };\n    AntiCsrfToken.removeToken = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0, logger_1.logDebugMessage)(\"AntiCsrfToken.removeToken: called\");\n                        AntiCsrfToken.tokenInfo = undefined;\n                        return [4 /*yield*/, setAntiCSRF(undefined)];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AntiCsrfToken.setItem = function(associatedIdRefreshToken, antiCsrf) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (associatedIdRefreshToken === undefined) {\n                            AntiCsrfToken.tokenInfo = undefined;\n                            return [2 /*return*/];\n                        }\n                        (0, logger_1.logDebugMessage)(\"AntiCsrfToken.setItem: called\");\n                        return [4 /*yield*/, setAntiCSRF(antiCsrf)];\n                    case 1:\n                        _a.sent();\n                        AntiCsrfToken.tokenInfo = {\n                            antiCsrf: antiCsrf,\n                            associatedIdRefreshToken: associatedIdRefreshToken\n                        };\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return AntiCsrfToken;\n})();\nexports.AntiCsrfToken = AntiCsrfToken;\n// Note: We do not store this in memory because another tab may have\n// modified this value, and if so, we may not know about it in this tab\nvar FrontToken = /** @class */ (function() {\n    function FrontToken() {}\n    FrontToken.getTokenInfo = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var frontToken, response;\n            return __generator(this, function(_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: called\");\n                        return [4 /*yield*/, getFrontToken()];\n                    case 1:\n                        frontToken = _a.sent();\n                        if (!(frontToken === null)) return [3 /*break*/, 5];\n                        return [4 /*yield*/, getIdRefreshToken(false)];\n                    case 2:\n                        if (!(_a.sent().status === \"EXISTS\")) return [3 /*break*/, 4];\n                        // this means that the id refresh token has been set, so we must\n                        // wait for this to be set or removed\n                        return [\n                            4 /*yield*/,\n                            new Promise(function(resolve) {\n                                FrontToken.waiters.push(resolve);\n                            })\n                        ];\n                    case 3:\n                        // this means that the id refresh token has been set, so we must\n                        // wait for this to be set or removed\n                        _a.sent();\n                        return [2 /*return*/, FrontToken.getTokenInfo()];\n                    case 4:\n                        return [2 /*return*/, undefined];\n                    case 5:\n                        response = parseFrontToken(frontToken);\n                        (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: returning ate: \" + response.ate);\n                        (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: returning uid: \" + response.uid);\n                        (0, logger_1.logDebugMessage)(\"FrontToken.getTokenInfo: returning up: \" + response.up);\n                        return [2 /*return*/, response];\n                }\n            });\n        });\n    };\n    FrontToken.removeToken = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0, logger_1.logDebugMessage)(\"FrontToken.removeToken: called\");\n                        return [4 /*yield*/, setFrontToken(undefined)];\n                    case 1:\n                        _a.sent();\n                        FrontToken.waiters.forEach(function(f) {\n                            return f(undefined);\n                        });\n                        FrontToken.waiters = [];\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FrontToken.setItem = function(frontToken) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0, logger_1.logDebugMessage)(\"FrontToken.setItem: called\");\n                        return [4 /*yield*/, setFrontToken(frontToken)];\n                    case 1:\n                        _a.sent();\n                        FrontToken.waiters.forEach(function(f) {\n                            return f(undefined);\n                        });\n                        FrontToken.waiters = [];\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // these are waiters for when the idRefreshToken has been set, but this token has\n    // not yet been set. Once this token is set or removed, the waiters are resolved.\n    FrontToken.waiters = [];\n    return FrontToken;\n})();\nexports.FrontToken = FrontToken;\n/**\n * @class AuthHttpRequest\n * @description wrapper for common http methods.\n */\nvar AuthHttpRequest = /** @class */ (function() {\n    function AuthHttpRequest() {}\n    AuthHttpRequest.init = function(config, recipeImpl) {\n        (0, logger_1.logDebugMessage)(\"init: called\");\n        (0, logger_1.logDebugMessage)(\"init: Input apiBasePath: \" + config.apiBasePath);\n        (0, logger_1.logDebugMessage)(\"init: Input apiDomain: \" + config.apiDomain);\n        (0, logger_1.logDebugMessage)(\"init: Input autoAddCredentials: \" + config.autoAddCredentials);\n        (0, logger_1.logDebugMessage)(\"init: Input cookieDomain: \" + config.cookieDomain);\n        (0, logger_1.logDebugMessage)(\"init: Input isInIframe: \" + config.isInIframe);\n        (0, logger_1.logDebugMessage)(\"init: Input sessionExpiredStatusCode: \" + config.sessionExpiredStatusCode);\n        (0, logger_1.logDebugMessage)(\"init: Input sessionScope: \" + config.sessionScope);\n        AuthHttpRequest.env = getWindowOrThrow().fetch === undefined ? global : getWindowOrThrow();\n        AuthHttpRequest.refreshTokenUrl = config.apiDomain + config.apiBasePath + \"/session/refresh\";\n        AuthHttpRequest.signOutUrl = config.apiDomain + config.apiBasePath + \"/signout\";\n        AuthHttpRequest.rid = \"session\";\n        AuthHttpRequest.config = config;\n        if (AuthHttpRequest.env.__supertokensOriginalFetch === undefined) {\n            (0, logger_1.logDebugMessage)(\"init: __supertokensOriginalFetch is undefined\");\n            // this block contains code that is run just once per page load..\n            // all items in this block are attached to the global env so that\n            // even if the init function is called more than once (maybe across JS scripts),\n            // things will not get created multiple times.\n            AuthHttpRequest.env.__supertokensOriginalFetch = AuthHttpRequest.env.fetch.bind(AuthHttpRequest.env);\n            AuthHttpRequest.env.__supertokensSessionRecipe = recipeImpl;\n            AuthHttpRequest.env.fetch = AuthHttpRequest.env.__supertokensSessionRecipe.addFetchInterceptorsAndReturnModifiedFetch(\n                {\n                    originalFetch: AuthHttpRequest.env.__supertokensOriginalFetch,\n                    userContext: {}\n                }\n            );\n            AuthHttpRequest.env.__supertokensSessionRecipe.addXMLHttpRequestInterceptor({\n                userContext: {}\n            });\n        }\n        AuthHttpRequest.recipeImpl = AuthHttpRequest.env.__supertokensSessionRecipe;\n        AuthHttpRequest.initCalled = true;\n    };\n    var _a;\n    _a = AuthHttpRequest;\n    AuthHttpRequest.initCalled = false;\n    AuthHttpRequest.doRequest = function(httpCall, config, url) {\n        return __awaiter(void 0, void 0, void 0, function() {\n            var doNotDoInterception,\n                returnObj,\n                preRequestIdToken,\n                clonedHeaders,\n                configWithAntiCsrf,\n                antiCsrfToken,\n                response,\n                idRefreshToken,\n                retry,\n                antiCsrfToken,\n                tok,\n                frontToken,\n                postRequestIdToken;\n            return __generator(_a, function(_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!AuthHttpRequest.initCalled) {\n                            throw Error(\"init function not called\");\n                        }\n                        (0, logger_1.logDebugMessage)(\"doRequest: start of fetch interception\");\n                        doNotDoInterception = false;\n                        try {\n                            doNotDoInterception =\n                                (typeof url === \"string\" &&\n                                    !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                        url,\n                                        AuthHttpRequest.config.apiDomain,\n                                        AuthHttpRequest.config.cookieDomain\n                                    )) ||\n                                (url !== undefined &&\n                                typeof url.url === \"string\" && // this is because url can be an object like {method: ..., url: ...}\n                                    !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                        url.url,\n                                        AuthHttpRequest.config.apiDomain,\n                                        AuthHttpRequest.config.cookieDomain\n                                    ));\n                        } catch (err) {\n                            if (err.message === \"Please provide a valid domain name\") {\n                                (0, logger_1.logDebugMessage)(\n                                    \"doRequest: Trying shouldDoInterceptionBasedOnUrl with location.origin\"\n                                );\n                                // .origin gives the port as well..\n                                doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                    windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(),\n                                    AuthHttpRequest.config.apiDomain,\n                                    AuthHttpRequest.config.cookieDomain\n                                );\n                            } else {\n                                throw err;\n                            }\n                        }\n                        (0,\n                        logger_1.logDebugMessage)(\"doRequest: Value of doNotDoInterception: \" + doNotDoInterception);\n                        if (!doNotDoInterception) return [3 /*break*/, 2];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Returning without interception\");\n                        return [4 /*yield*/, httpCall(config)];\n                    case 1:\n                        return [2 /*return*/, _b.sent()];\n                    case 2:\n                        (0, logger_1.logDebugMessage)(\"doRequest: Interception started\");\n                        processState_1.ProcessState.getInstance().addState(\n                            processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST\n                        );\n                        _b.label = 3;\n                    case 3:\n                        _b.trys.push([3, , 22, 27]);\n                        returnObj = undefined;\n                        _b.label = 4;\n                    case 4:\n                        if (!true) return [3 /*break*/, 21];\n                        return [4 /*yield*/, getIdRefreshToken(true)];\n                    case 5:\n                        preRequestIdToken = _b.sent();\n                        clonedHeaders = new Headers(\n                            config !== undefined && config.headers !== undefined ? config.headers : url.headers\n                        );\n                        configWithAntiCsrf = __assign(__assign({}, config), { headers: clonedHeaders });\n                        if (!(preRequestIdToken.status === \"EXISTS\")) return [3 /*break*/, 7];\n                        return [4 /*yield*/, AntiCsrfToken.getToken(preRequestIdToken.token)];\n                    case 6:\n                        antiCsrfToken = _b.sent();\n                        if (antiCsrfToken !== undefined) {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Adding anti-csrf token to request\");\n                            clonedHeaders.set(\"anti-csrf\", antiCsrfToken);\n                        }\n                        _b.label = 7;\n                    case 7:\n                        if (AuthHttpRequest.config.autoAddCredentials) {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Adding credentials include\");\n                            if (configWithAntiCsrf === undefined) {\n                                configWithAntiCsrf = {\n                                    credentials: \"include\"\n                                };\n                            } else if (configWithAntiCsrf.credentials === undefined) {\n                                configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                                    credentials: \"include\"\n                                });\n                            }\n                        }\n                        // adding rid for anti-csrf protection: Anti-csrf via custom header\n                        if (!clonedHeaders.has(\"rid\")) {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Adding rid header: anti-csrf\");\n                            clonedHeaders.set(\"rid\", \"anti-csrf\");\n                        } else {\n                            (0, logger_1.logDebugMessage)(\"doRequest: rid header was already there in request\");\n                        }\n                        (0, logger_1.logDebugMessage)(\"doRequest: Making user's http call\");\n                        return [4 /*yield*/, httpCall(configWithAntiCsrf)];\n                    case 8:\n                        response = _b.sent();\n                        (0, logger_1.logDebugMessage)(\"doRequest: User's http call ended\");\n                        idRefreshToken = response.headers.get(\"id-refresh-token\");\n                        if (!idRefreshToken) return [3 /*break*/, 10];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Setting sIRTFrontend: \" + idRefreshToken);\n                        return [4 /*yield*/, setIdRefreshToken(idRefreshToken, response.status)];\n                    case 9:\n                        _b.sent();\n                        _b.label = 10;\n                    case 10:\n                        if (!(response.status === AuthHttpRequest.config.sessionExpiredStatusCode))\n                            return [3 /*break*/, 12];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Status code is: \" + response.status);\n                        return [4 /*yield*/, onUnauthorisedResponse(preRequestIdToken)];\n                    case 11:\n                        retry = _b.sent();\n                        if (retry.result !== \"RETRY\") {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Not retrying original request\");\n                            returnObj = retry.error !== undefined ? retry.error : response;\n                            return [3 /*break*/, 21];\n                        }\n                        (0, logger_1.logDebugMessage)(\"doRequest: Retrying original request\");\n                        return [3 /*break*/, 20];\n                    case 12:\n                        if (!(response.status === AuthHttpRequest.config.invalidClaimStatusCode))\n                            return [3 /*break*/, 14];\n                        return [4 /*yield*/, onInvalidClaimResponse(response)];\n                    case 13:\n                        _b.sent();\n                        _b.label = 14;\n                    case 14:\n                        antiCsrfToken = response.headers.get(\"anti-csrf\");\n                        if (!antiCsrfToken) return [3 /*break*/, 17];\n                        return [4 /*yield*/, getIdRefreshToken(true)];\n                    case 15:\n                        tok = _b.sent();\n                        if (!(tok.status === \"EXISTS\")) return [3 /*break*/, 17];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Setting anti-csrf token\");\n                        return [4 /*yield*/, AntiCsrfToken.setItem(tok.token, antiCsrfToken)];\n                    case 16:\n                        _b.sent();\n                        _b.label = 17;\n                    case 17:\n                        frontToken = response.headers.get(\"front-token\");\n                        if (!frontToken) return [3 /*break*/, 19];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Setting sFrontToken: \" + frontToken);\n                        return [4 /*yield*/, FrontToken.setItem(frontToken)];\n                    case 18:\n                        _b.sent();\n                        _b.label = 19;\n                    case 19:\n                        return [2 /*return*/, response];\n                    case 20:\n                        return [3 /*break*/, 4];\n                    case 21:\n                        // if it comes here, means we breaked. which happens only if we have logged out.\n                        return [2 /*return*/, returnObj];\n                    case 22:\n                        return [4 /*yield*/, getIdRefreshToken(false)];\n                    case 23:\n                        postRequestIdToken = _b.sent();\n                        if (!(postRequestIdToken.status === \"NOT_EXISTS\")) return [3 /*break*/, 26];\n                        (0,\n                        logger_1.logDebugMessage)(\"doRequest: sIRTFrontend doesn't exist, so removing anti-csrf and sFrontToken\");\n                        return [4 /*yield*/, AntiCsrfToken.removeToken()];\n                    case 24:\n                        _b.sent();\n                        return [4 /*yield*/, FrontToken.removeToken()];\n                    case 25:\n                        _b.sent();\n                        _b.label = 26;\n                    case 26:\n                        return [7 /*endfinally*/];\n                    case 27:\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AuthHttpRequest.attemptRefreshingSession = function() {\n        return __awaiter(void 0, void 0, void 0, function() {\n            var preRequestIdToken, refresh;\n            return __generator(_a, function(_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!AuthHttpRequest.initCalled) {\n                            throw Error(\"init function not called\");\n                        }\n                        return [4 /*yield*/, getIdRefreshToken(false)];\n                    case 1:\n                        preRequestIdToken = _b.sent();\n                        return [4 /*yield*/, onUnauthorisedResponse(preRequestIdToken)];\n                    case 2:\n                        refresh = _b.sent();\n                        if (refresh.result === \"API_ERROR\") {\n                            throw refresh.error;\n                        }\n                        return [2 /*return*/, refresh.result === \"RETRY\"];\n                }\n            });\n        });\n    };\n    return AuthHttpRequest;\n})();\nexports.default = AuthHttpRequest;\nvar ID_REFRESH_TOKEN_NAME = \"sIRTFrontend\";\nvar ANTI_CSRF_NAME = \"sAntiCsrf\";\nvar FRONT_TOKEN_NAME = \"sFrontToken\";\n/**\n * @description attempts to call the refresh token API each time we are sure the session has expired, or it throws an error or,\n * or the ID_COOKIE_NAME has changed value -> which may mean that we have a new set of tokens.\n */\nfunction onUnauthorisedResponse(preRequestIdToken) {\n    return __awaiter(this, void 0, void 0, function() {\n        var lock,\n            postLockID,\n            headers,\n            antiCsrfToken_1,\n            preAPIResult,\n            response,\n            removeIdRefreshToken,\n            idRefreshToken,\n            antiCsrfToken,\n            tok,\n            frontToken,\n            error_1,\n            idCookieValue;\n        return __generator(this, function(_b) {\n            switch (_b.label) {\n                case 0:\n                    lock = new browser_tabs_lock_1.default();\n                    _b.label = 1;\n                case 1:\n                    if (!true) return [3 /*break*/, 30];\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: trying to acquire lock\");\n                    return [4 /*yield*/, lock.acquireLock(\"REFRESH_TOKEN_USE\", 1000)];\n                case 2:\n                    if (!_b.sent()) return [3 /*break*/, 28];\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: lock acquired\");\n                    _b.label = 3;\n                case 3:\n                    _b.trys.push([3, 20, 22, 28]);\n                    return [4 /*yield*/, getIdRefreshToken(false)];\n                case 4:\n                    postLockID = _b.sent();\n                    if (postLockID.status === \"NOT_EXISTS\") {\n                        (0, logger_1.logDebugMessage)(\n                            \"onUnauthorisedResponse: Not refreshing because sIRTFrontend is remove\"\n                        );\n                        // if it comes here, it means a request was made thinking\n                        // that the session exists, but it doesn't actually exist.\n                        AuthHttpRequest.config.onHandleEvent({\n                            action: \"UNAUTHORISED\",\n                            sessionExpiredOrRevoked: false,\n                            userContext: {}\n                        });\n                        return [2 /*return*/, { result: \"SESSION_EXPIRED\" }];\n                    }\n                    if (\n                        postLockID.status !== preRequestIdToken.status ||\n                        (postLockID.status === \"EXISTS\" &&\n                            preRequestIdToken.status === \"EXISTS\" &&\n                            postLockID.token !== preRequestIdToken.token)\n                    ) {\n                        (0, logger_1.logDebugMessage)(\n                            \"onUnauthorisedResponse: Retrying early because pre and post id refresh tokens don't match\"\n                        );\n                        // means that some other process has already called this API and succeeded. so we need to call it again\n                        return [2 /*return*/, { result: \"RETRY\" }];\n                    }\n                    headers = {};\n                    if (!(preRequestIdToken.status === \"EXISTS\")) return [3 /*break*/, 6];\n                    return [4 /*yield*/, AntiCsrfToken.getToken(preRequestIdToken.token)];\n                case 5:\n                    antiCsrfToken_1 = _b.sent();\n                    if (antiCsrfToken_1 !== undefined) {\n                        (0, logger_1.logDebugMessage)(\n                            \"onUnauthorisedResponse: Adding anti-csrf token to refresh API call\"\n                        );\n                        headers = __assign(__assign({}, headers), { \"anti-csrf\": antiCsrfToken_1 });\n                    }\n                    _b.label = 6;\n                case 6:\n                    (0,\n                    logger_1.logDebugMessage)(\"onUnauthorisedResponse: Adding rid and fdi-versions to refresh call header\");\n                    headers = __assign(__assign({ rid: AuthHttpRequest.rid }, headers), {\n                        \"fdi-version\": version_1.supported_fdi.join(\",\")\n                    });\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Calling refresh pre API hook\");\n                    return [\n                        4 /*yield*/,\n                        AuthHttpRequest.config.preAPIHook({\n                            action: \"REFRESH_SESSION\",\n                            requestInit: {\n                                method: \"post\",\n                                credentials: \"include\",\n                                headers: headers\n                            },\n                            url: AuthHttpRequest.refreshTokenUrl,\n                            userContext: {}\n                        })\n                    ];\n                case 7:\n                    preAPIResult = _b.sent();\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Making refresh call\");\n                    return [\n                        4 /*yield*/,\n                        AuthHttpRequest.env.__supertokensOriginalFetch(preAPIResult.url, preAPIResult.requestInit)\n                    ];\n                case 8:\n                    response = _b.sent();\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Refresh call ended\");\n                    removeIdRefreshToken = true;\n                    idRefreshToken = response.headers.get(\"id-refresh-token\");\n                    if (!idRefreshToken) return [3 /*break*/, 10];\n                    (0,\n                    logger_1.logDebugMessage)(\"onUnauthorisedResponse: Setting sIRTFrontend from refresh API call: \" + idRefreshToken);\n                    return [4 /*yield*/, setIdRefreshToken(idRefreshToken, response.status)];\n                case 9:\n                    _b.sent();\n                    removeIdRefreshToken = false;\n                    _b.label = 10;\n                case 10:\n                    if (!(response.status === AuthHttpRequest.config.sessionExpiredStatusCode))\n                        return [3 /*break*/, 12];\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Refresh status code is: \" + response.status);\n                    if (!removeIdRefreshToken) return [3 /*break*/, 12];\n                    return [4 /*yield*/, setIdRefreshToken(\"remove\", response.status)];\n                case 11:\n                    _b.sent();\n                    _b.label = 12;\n                case 12:\n                    if (response.status >= 300) {\n                        throw response;\n                    }\n                    return [\n                        4 /*yield*/,\n                        AuthHttpRequest.config.postAPIHook({\n                            action: \"REFRESH_SESSION\",\n                            fetchResponse: response.clone(),\n                            requestInit: preAPIResult.requestInit,\n                            url: preAPIResult.url,\n                            userContext: {}\n                        })\n                    ];\n                case 13:\n                    _b.sent();\n                    return [4 /*yield*/, getIdRefreshToken(false)];\n                case 14:\n                    if (_b.sent().status === \"NOT_EXISTS\") {\n                        (0, logger_1.logDebugMessage)(\n                            \"onUnauthorisedResponse: sIRTFrontend is remove, so returning session expired\"\n                        );\n                        // The execution should never come here.. but just in case.\n                        // removed by server. So we logout\n                        // we do not send \"UNAUTHORISED\" event here because\n                        // this is a result of the refresh API returning a session expiry, which\n                        // means that the frontend did not know for sure that the session existed\n                        // in the first place.\n                        return [2 /*return*/, { result: \"SESSION_EXPIRED\" }];\n                    }\n                    antiCsrfToken = response.headers.get(\"anti-csrf\");\n                    if (!antiCsrfToken) return [3 /*break*/, 17];\n                    return [4 /*yield*/, getIdRefreshToken(true)];\n                case 15:\n                    tok = _b.sent();\n                    if (!(tok.status === \"EXISTS\")) return [3 /*break*/, 17];\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: setting anti-csrf token\");\n                    return [4 /*yield*/, AntiCsrfToken.setItem(tok.token, antiCsrfToken)];\n                case 16:\n                    _b.sent();\n                    _b.label = 17;\n                case 17:\n                    frontToken = response.headers.get(\"front-token\");\n                    if (!frontToken) return [3 /*break*/, 19];\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: setting sFrontToken: \" + frontToken);\n                    return [4 /*yield*/, FrontToken.setItem(frontToken)];\n                case 18:\n                    _b.sent();\n                    _b.label = 19;\n                case 19:\n                    AuthHttpRequest.config.onHandleEvent({\n                        action: \"REFRESH_SESSION\",\n                        userContext: {}\n                    });\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Sending RETRY signal\");\n                    return [2 /*return*/, { result: \"RETRY\" }];\n                case 20:\n                    error_1 = _b.sent();\n                    return [4 /*yield*/, getIdRefreshToken(false)];\n                case 21:\n                    if (_b.sent().status === \"NOT_EXISTS\") {\n                        (0, logger_1.logDebugMessage)(\n                            \"onUnauthorisedResponse: sIRTFrontend is remove, so returning session expired\"\n                        );\n                        // removed by server.\n                        // we do not send \"UNAUTHORISED\" event here because\n                        // this is a result of the refresh API returning a session expiry, which\n                        // means that the frontend did not know for sure that the session existed\n                        // in the first place.\n                        return [2 /*return*/, { result: \"SESSION_EXPIRED\", error: error_1 }];\n                    }\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: sending API_ERROR\");\n                    return [2 /*return*/, { result: \"API_ERROR\", error: error_1 }];\n                case 22:\n                    return [4 /*yield*/, lock.releaseLock(\"REFRESH_TOKEN_USE\")];\n                case 23:\n                    _b.sent();\n                    (0, logger_1.logDebugMessage)(\"onUnauthorisedResponse: Released lock\");\n                    return [4 /*yield*/, getIdRefreshToken(false)];\n                case 24:\n                    if (!(_b.sent().status === \"NOT_EXISTS\")) return [3 /*break*/, 27];\n                    (0,\n                    logger_1.logDebugMessage)(\"onUnauthorisedResponse: sIRTFrontend is remove, so removing anti-csrf and sFrontToken\");\n                    return [4 /*yield*/, AntiCsrfToken.removeToken()];\n                case 25:\n                    _b.sent();\n                    return [4 /*yield*/, FrontToken.removeToken()];\n                case 26:\n                    _b.sent();\n                    _b.label = 27;\n                case 27:\n                    return [7 /*endfinally*/];\n                case 28:\n                    return [4 /*yield*/, getIdRefreshToken(false)];\n                case 29:\n                    idCookieValue = _b.sent();\n                    if (idCookieValue.status === \"NOT_EXISTS\") {\n                        (0, logger_1.logDebugMessage)(\n                            \"onUnauthorisedResponse: lock acquired failed and sIRTFrontend is remove, so sending SESSION_EXPIRED\"\n                        );\n                        // removed by server. So we logout\n                        return [2 /*return*/, { result: \"SESSION_EXPIRED\" }];\n                    } else {\n                        if (\n                            idCookieValue.status !== preRequestIdToken.status ||\n                            (idCookieValue.status === \"EXISTS\" &&\n                                preRequestIdToken.status === \"EXISTS\" &&\n                                idCookieValue.token !== preRequestIdToken.token)\n                        ) {\n                            (0, logger_1.logDebugMessage)(\n                                \"onUnauthorisedResponse: lock acquired failed and retrying early because pre and post id refresh tokens don't match\"\n                            );\n                            return [2 /*return*/, { result: \"RETRY\" }];\n                        }\n                        // here we try to call the API again since we probably failed to acquire lock and nothing has changed.\n                    }\n                    return [3 /*break*/, 1];\n                case 30:\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.onUnauthorisedResponse = onUnauthorisedResponse;\nfunction onTokenUpdate() {\n    (0, logger_1.logDebugMessage)(\"onTokenUpdate: firing ACCESS_TOKEN_PAYLOAD_UPDATED event\");\n    AuthHttpRequest.config.onHandleEvent({\n        action: \"ACCESS_TOKEN_PAYLOAD_UPDATED\",\n        userContext: {}\n    });\n}\nexports.onTokenUpdate = onTokenUpdate;\nfunction onInvalidClaimResponse(response) {\n    return __awaiter(this, void 0, void 0, function() {\n        var claimValidationErrors, _b;\n        return __generator(this, function(_c) {\n            switch (_c.label) {\n                case 0:\n                    _c.trys.push([0, 2, , 3]);\n                    return [\n                        4 /*yield*/,\n                        AuthHttpRequest.recipeImpl.getInvalidClaimsFromResponse({\n                            response: response,\n                            userContext: {}\n                        })\n                    ];\n                case 1:\n                    claimValidationErrors = _c.sent();\n                    // This shouldn't be undefined normally, but since we can't be certain about the shape of the response object so we check it like this.\n                    // It could still be something else, but chance of that happening by accident is really low.\n                    if (claimValidationErrors) {\n                        AuthHttpRequest.config.onHandleEvent({\n                            action: \"API_INVALID_CLAIM\",\n                            claimValidationErrors: claimValidationErrors,\n                            userContext: {}\n                        });\n                    }\n                    return [3 /*break*/, 3];\n                case 2:\n                    _b = _c.sent();\n                    return [3 /*break*/, 3];\n                case 3:\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.onInvalidClaimResponse = onInvalidClaimResponse;\n// if tryRefresh is true & this token doesn't exist, we try and refresh the session\n// else we return undefined.\nfunction getIdRefreshToken(tryRefresh) {\n    return __awaiter(this, void 0, void 0, function() {\n        function getIdRefreshTokenFromLocal() {\n            return __awaiter(this, void 0, void 0, function() {\n                function getIDFromCookieOld() {\n                    return __awaiter(this, void 0, void 0, function() {\n                        var value, _b, parts, last;\n                        return __generator(this, function(_c) {\n                            switch (_c.label) {\n                                case 0:\n                                    _b = \"; \";\n                                    return [\n                                        4 /*yield*/,\n                                        cookieHandler_1.default.getReferenceOrThrow().cookieHandler.getCookie()\n                                    ];\n                                case 1:\n                                    value = _b + _c.sent();\n                                    parts = value.split(\"; \" + ID_REFRESH_TOKEN_NAME + \"=\");\n                                    if (parts.length >= 2) {\n                                        last = parts.pop();\n                                        if (last === \"remove\") {\n                                            // it means no session exists. This is different from\n                                            // it being undefined since in that case a session may or may not exist.\n                                            return [2 /*return*/, \"remove\"];\n                                        }\n                                        if (last !== undefined) {\n                                            return [2 /*return*/, last.split(\";\").shift()];\n                                        }\n                                    }\n                                    return [2 /*return*/, undefined];\n                            }\n                        });\n                    });\n                }\n                var fromCookie;\n                return __generator(this, function(_b) {\n                    switch (_b.label) {\n                        case 0:\n                            return [4 /*yield*/, getIDFromCookieOld()];\n                        case 1:\n                            fromCookie = _b.sent();\n                            return [2 /*return*/, fromCookie];\n                    }\n                });\n            });\n        }\n        var token, response, res;\n        return __generator(this, function(_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"getIdRefreshToken: called\");\n                    return [4 /*yield*/, getIdRefreshTokenFromLocal()];\n                case 1:\n                    token = _b.sent();\n                    if (token === \"remove\") {\n                        (0, logger_1.logDebugMessage)(\"getIdRefreshToken: is removed\");\n                        return [\n                            2 /*return*/,\n                            {\n                                status: \"NOT_EXISTS\"\n                            }\n                        ];\n                    }\n                    if (!(token === undefined)) return [3 /*break*/, 5];\n                    (0, logger_1.logDebugMessage)(\"getIdRefreshToken: is undefined\");\n                    response = {\n                        status: \"MAY_EXIST\"\n                    };\n                    if (!tryRefresh) return [3 /*break*/, 4];\n                    (0, logger_1.logDebugMessage)(\"getIdRefreshToken: trying to refresg\");\n                    return [4 /*yield*/, onUnauthorisedResponse(response)];\n                case 2:\n                    res = _b.sent();\n                    if (res.result !== \"RETRY\") {\n                        (0, logger_1.logDebugMessage)(\"getIdRefreshToken: false NOT_EXISTS in case error from backend\");\n                        // in case the backend is not working, we treat it as the session not existing...\n                        return [\n                            2 /*return*/,\n                            {\n                                status: \"NOT_EXISTS\"\n                            }\n                        ];\n                    }\n                    (0, logger_1.logDebugMessage)(\"getIdRefreshToken: Retrying post refresh\");\n                    return [4 /*yield*/, getIdRefreshToken(tryRefresh)];\n                case 3:\n                    return [2 /*return*/, _b.sent()];\n                case 4:\n                    (0, logger_1.logDebugMessage)(\"getIdRefreshToken: returning: \" + response.status);\n                    return [2 /*return*/, response];\n                case 5:\n                    (0, logger_1.logDebugMessage)(\"getIdRefreshToken: returning EXISTS: \" + token);\n                    return [\n                        2 /*return*/,\n                        {\n                            status: \"EXISTS\",\n                            token: token\n                        }\n                    ];\n            }\n        });\n    });\n}\nexports.getIdRefreshToken = getIdRefreshToken;\nfunction setIdRefreshToken(idRefreshToken, statusCode) {\n    return __awaiter(this, void 0, void 0, function() {\n        function setIDToCookie(idRefreshToken, domain) {\n            return __awaiter(this, void 0, void 0, function() {\n                var expires, cookieVal, splitted;\n                return __generator(this, function(_b) {\n                    switch (_b.label) {\n                        case 0:\n                            expires = \"Fri, 31 Dec 9999 23:59:59 GMT\";\n                            cookieVal = \"remove\";\n                            if (idRefreshToken !== \"remove\") {\n                                splitted = idRefreshToken.split(\";\");\n                                cookieVal = splitted[0];\n                                // we must always respect this expiry and not set it to infinite\n                                // cause this ties into the session's lifetime. If we set this\n                                // to infinite, then a session may not exist, and this will exist,\n                                // then for example, if we check a session exists, and this says yes,\n                                // then if we getAccessTokenPayload, that will attempt a session refresh which will fail.\n                                // Another reason to respect this is that if we don't, then signOut will\n                                // call the API which will return 200 (no 401 cause the API thinks no session exists),\n                                // in which case, we will not end up firing the SIGN_OUT on handle event.\n                                expires = new Date(Number(splitted[1])).toUTCString();\n                            }\n                            if (\n                                !(\n                                    domain === \"localhost\" ||\n                                    domain ===\n                                        windowHandler_1.default\n                                            .getReferenceOrThrow()\n                                            .windowHandler.location.getHostName()\n                                )\n                            )\n                                return [3 /*break*/, 2];\n                            // since some browsers ignore cookies with domain set to localhost\n                            // see https://github.com/supertokens/supertokens-website/issues/25\n                            return [\n                                4 /*yield*/,\n                                cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\n                                    \"\"\n                                        .concat(ID_REFRESH_TOKEN_NAME, \"=\")\n                                        .concat(cookieVal, \";expires=\")\n                                        .concat(expires, \";path=/;samesite=\")\n                                        .concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\")\n                                )\n                            ];\n                        case 1:\n                            // since some browsers ignore cookies with domain set to localhost\n                            // see https://github.com/supertokens/supertokens-website/issues/25\n                            _b.sent();\n                            return [3 /*break*/, 4];\n                        case 2:\n                            return [\n                                4 /*yield*/,\n                                cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\n                                    \"\"\n                                        .concat(ID_REFRESH_TOKEN_NAME, \"=\")\n                                        .concat(cookieVal, \";expires=\")\n                                        .concat(expires, \";domain=\")\n                                        .concat(domain, \";path=/;samesite=\")\n                                        .concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\")\n                                )\n                            ];\n                        case 3:\n                            _b.sent();\n                            _b.label = 4;\n                        case 4:\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        }\n        var status;\n        return __generator(this, function(_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"setIdRefreshToken: called\");\n                    return [4 /*yield*/, getIdRefreshToken(false)];\n                case 1:\n                    status = _b.sent().status;\n                    (0, logger_1.logDebugMessage)(\"setIdRefreshToken: setting: \" + idRefreshToken);\n                    return [4 /*yield*/, setIDToCookie(idRefreshToken, AuthHttpRequest.config.sessionScope)];\n                case 2:\n                    _b.sent();\n                    if (idRefreshToken === \"remove\" && status === \"EXISTS\") {\n                        // we check for wasLoggedIn cause we don't want to fire an event\n                        // unnecessarily on first app load or if the user tried\n                        // to query an API that returned 401 while the user was not logged in...\n                        if (statusCode === AuthHttpRequest.config.sessionExpiredStatusCode) {\n                            (0, logger_1.logDebugMessage)(\"setIdRefreshToken: firing UNAUTHORISED event\");\n                            AuthHttpRequest.config.onHandleEvent({\n                                action: \"UNAUTHORISED\",\n                                sessionExpiredOrRevoked: true,\n                                userContext: {}\n                            });\n                        } else {\n                            (0, logger_1.logDebugMessage)(\"setIdRefreshToken: firing SIGN_OUT event\");\n                            AuthHttpRequest.config.onHandleEvent({\n                                action: \"SIGN_OUT\",\n                                userContext: {}\n                            });\n                        }\n                    }\n                    if (idRefreshToken !== \"remove\" && status === \"NOT_EXISTS\") {\n                        (0, logger_1.logDebugMessage)(\"setIdRefreshToken: firing SESSION_CREATED event\");\n                        AuthHttpRequest.config.onHandleEvent({\n                            action: \"SESSION_CREATED\",\n                            userContext: {}\n                        });\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.setIdRefreshToken = setIdRefreshToken;\nfunction getAntiCSRFToken() {\n    return __awaiter(this, void 0, void 0, function() {\n        function getAntiCSRFromCookie() {\n            return __awaiter(this, void 0, void 0, function() {\n                var value, _b, parts, last, temp;\n                return __generator(this, function(_c) {\n                    switch (_c.label) {\n                        case 0:\n                            _b = \"; \";\n                            return [\n                                4 /*yield*/,\n                                cookieHandler_1.default.getReferenceOrThrow().cookieHandler.getCookie()\n                            ];\n                        case 1:\n                            value = _b + _c.sent();\n                            parts = value.split(\"; \" + ANTI_CSRF_NAME + \"=\");\n                            if (parts.length >= 2) {\n                                last = parts.pop();\n                                if (last !== undefined) {\n                                    temp = last.split(\";\").shift();\n                                    if (temp === undefined) {\n                                        return [2 /*return*/, null];\n                                    }\n                                    return [2 /*return*/, temp];\n                                }\n                            }\n                            return [2 /*return*/, null];\n                    }\n                });\n            });\n        }\n        var fromCookie;\n        return __generator(this, function(_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"getAntiCSRFToken: called\");\n                    return [4 /*yield*/, getIdRefreshToken(true)];\n                case 1:\n                    // we do not call doesSessionExist here cause the user might override that\n                    // function here and then it may break the logic of our original implementation.\n                    if (!(_b.sent().status === \"EXISTS\")) {\n                        (0, logger_1.logDebugMessage)(\"getAntiCSRFToken: Returning because sIRTFrontend != EXISTS\");\n                        return [2 /*return*/, null];\n                    }\n                    return [4 /*yield*/, getAntiCSRFromCookie()];\n                case 2:\n                    fromCookie = _b.sent();\n                    (0, logger_1.logDebugMessage)(\"getAntiCSRFToken: returning: \" + fromCookie);\n                    return [2 /*return*/, fromCookie];\n            }\n        });\n    });\n}\n// give antiCSRFToken as undefined to remove it.\nfunction setAntiCSRF(antiCSRFToken) {\n    return __awaiter(this, void 0, void 0, function() {\n        function setAntiCSRFToCookie(antiCSRFToken, domain) {\n            return __awaiter(this, void 0, void 0, function() {\n                var expires, cookieVal;\n                return __generator(this, function(_b) {\n                    switch (_b.label) {\n                        case 0:\n                            expires = \"Thu, 01 Jan 1970 00:00:01 GMT\";\n                            cookieVal = \"\";\n                            if (antiCSRFToken !== undefined) {\n                                cookieVal = antiCSRFToken;\n                                expires = undefined; // set cookie without expiry\n                            }\n                            if (\n                                !(\n                                    domain === \"localhost\" ||\n                                    domain ===\n                                        windowHandler_1.default\n                                            .getReferenceOrThrow()\n                                            .windowHandler.location.getHostName()\n                                )\n                            )\n                                return [3 /*break*/, 5];\n                            if (!(expires !== undefined)) return [3 /*break*/, 2];\n                            return [\n                                4 /*yield*/,\n                                cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\n                                    \"\"\n                                        .concat(ANTI_CSRF_NAME, \"=\")\n                                        .concat(cookieVal, \";expires=\")\n                                        .concat(expires, \";path=/;samesite=\")\n                                        .concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\")\n                                )\n                            ];\n                        case 1:\n                            _b.sent();\n                            return [3 /*break*/, 4];\n                        case 2:\n                            return [\n                                4 /*yield*/,\n                                cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\n                                    \"\"\n                                        .concat(ANTI_CSRF_NAME, \"=\")\n                                        .concat(cookieVal, \";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=\")\n                                        .concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\")\n                                )\n                            ];\n                        case 3:\n                            _b.sent();\n                            _b.label = 4;\n                        case 4:\n                            return [3 /*break*/, 9];\n                        case 5:\n                            if (!(expires !== undefined)) return [3 /*break*/, 7];\n                            return [\n                                4 /*yield*/,\n                                cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\n                                    \"\"\n                                        .concat(ANTI_CSRF_NAME, \"=\")\n                                        .concat(cookieVal, \";expires=\")\n                                        .concat(expires, \";domain=\")\n                                        .concat(domain, \";path=/;samesite=\")\n                                        .concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\")\n                                )\n                            ];\n                        case 6:\n                            _b.sent();\n                            return [3 /*break*/, 9];\n                        case 7:\n                            return [\n                                4 /*yield*/,\n                                cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\n                                    \"\"\n                                        .concat(ANTI_CSRF_NAME, \"=\")\n                                        .concat(cookieVal, \";domain=\")\n                                        .concat(domain, \";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=\")\n                                        .concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\")\n                                )\n                            ];\n                        case 8:\n                            _b.sent();\n                            _b.label = 9;\n                        case 9:\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        }\n        return __generator(this, function(_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"setAntiCSRF: called: \" + antiCSRFToken);\n                    return [4 /*yield*/, setAntiCSRFToCookie(antiCSRFToken, AuthHttpRequest.config.sessionScope)];\n                case 1:\n                    _b.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.setAntiCSRF = setAntiCSRF;\nfunction getFrontTokenFromCookie() {\n    return __awaiter(this, void 0, void 0, function() {\n        var value, _b, parts, last, temp;\n        return __generator(this, function(_c) {\n            switch (_c.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"getFrontTokenFromCookie: called\");\n                    _b = \"; \";\n                    return [4 /*yield*/, cookieHandler_1.default.getReferenceOrThrow().cookieHandler.getCookie()];\n                case 1:\n                    value = _b + _c.sent();\n                    parts = value.split(\"; \" + FRONT_TOKEN_NAME + \"=\");\n                    if (parts.length >= 2) {\n                        last = parts.pop();\n                        if (last !== undefined) {\n                            temp = last.split(\";\").shift();\n                            if (temp === undefined) {\n                                return [2 /*return*/, null];\n                            }\n                            return [2 /*return*/, temp];\n                        }\n                    }\n                    return [2 /*return*/, null];\n            }\n        });\n    });\n}\nfunction parseFrontToken(frontToken) {\n    return JSON.parse(decodeURIComponent(escape(atob(frontToken))));\n}\nfunction getFrontToken() {\n    return __awaiter(this, void 0, void 0, function() {\n        var fromCookie;\n        return __generator(this, function(_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"getFrontToken: called\");\n                    return [4 /*yield*/, getIdRefreshToken(true)];\n                case 1:\n                    // we do not call doesSessionExist here cause the user might override that\n                    // function here and then it may break the logic of our original implementation.\n                    if (!(_b.sent().status === \"EXISTS\")) {\n                        (0, logger_1.logDebugMessage)(\"getFrontToken: Returning because sIRTFrontend != EXISTS\");\n                        return [2 /*return*/, null];\n                    }\n                    return [4 /*yield*/, getFrontTokenFromCookie()];\n                case 2:\n                    fromCookie = _b.sent();\n                    (0, logger_1.logDebugMessage)(\"getFrontToken: returning: \" + fromCookie);\n                    return [2 /*return*/, fromCookie];\n            }\n        });\n    });\n}\nexports.getFrontToken = getFrontToken;\nfunction setFrontToken(frontToken) {\n    return __awaiter(this, void 0, void 0, function() {\n        function setFrontTokenToCookie(frontToken, domain) {\n            return __awaiter(this, void 0, void 0, function() {\n                var expires, cookieVal;\n                return __generator(this, function(_b) {\n                    switch (_b.label) {\n                        case 0:\n                            expires = \"Thu, 01 Jan 1970 00:00:01 GMT\";\n                            cookieVal = \"\";\n                            if (frontToken !== undefined) {\n                                cookieVal = frontToken;\n                                expires = undefined; // set cookie without expiry\n                            }\n                            if (\n                                !(\n                                    domain === \"localhost\" ||\n                                    domain ===\n                                        windowHandler_1.default\n                                            .getReferenceOrThrow()\n                                            .windowHandler.location.getHostName()\n                                )\n                            )\n                                return [3 /*break*/, 5];\n                            if (!(expires !== undefined)) return [3 /*break*/, 2];\n                            return [\n                                4 /*yield*/,\n                                cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\n                                    \"\"\n                                        .concat(FRONT_TOKEN_NAME, \"=\")\n                                        .concat(cookieVal, \";expires=\")\n                                        .concat(expires, \";path=/;samesite=\")\n                                        .concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\")\n                                )\n                            ];\n                        case 1:\n                            _b.sent();\n                            return [3 /*break*/, 4];\n                        case 2:\n                            return [\n                                4 /*yield*/,\n                                cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\n                                    \"\"\n                                        .concat(FRONT_TOKEN_NAME, \"=\")\n                                        .concat(cookieVal, \";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=\")\n                                        .concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\")\n                                )\n                            ];\n                        case 3:\n                            _b.sent();\n                            _b.label = 4;\n                        case 4:\n                            return [3 /*break*/, 9];\n                        case 5:\n                            if (!(expires !== undefined)) return [3 /*break*/, 7];\n                            return [\n                                4 /*yield*/,\n                                cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\n                                    \"\"\n                                        .concat(FRONT_TOKEN_NAME, \"=\")\n                                        .concat(cookieVal, \";expires=\")\n                                        .concat(expires, \";domain=\")\n                                        .concat(domain, \";path=/;samesite=\")\n                                        .concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\")\n                                )\n                            ];\n                        case 6:\n                            _b.sent();\n                            return [3 /*break*/, 9];\n                        case 7:\n                            return [\n                                4 /*yield*/,\n                                cookieHandler_1.default.getReferenceOrThrow().cookieHandler.setCookie(\n                                    \"\"\n                                        .concat(FRONT_TOKEN_NAME, \"=\")\n                                        .concat(cookieVal, \";domain=\")\n                                        .concat(domain, \";expires=Fri, 31 Dec 9999 23:59:59 GMT;path=/;samesite=\")\n                                        .concat(AuthHttpRequest.config.isInIframe ? \"none;secure\" : \"lax\")\n                                )\n                            ];\n                        case 8:\n                            _b.sent();\n                            _b.label = 9;\n                        case 9:\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        }\n        var oldToken, oldPayload, newPayload;\n        return __generator(this, function(_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"setFrontToken: called\");\n                    return [4 /*yield*/, getFrontTokenFromCookie()];\n                case 1:\n                    oldToken = _b.sent();\n                    if (oldToken !== null && frontToken !== undefined) {\n                        oldPayload = parseFrontToken(oldToken).up;\n                        newPayload = parseFrontToken(frontToken).up;\n                        if (JSON.stringify(oldPayload) !== JSON.stringify(newPayload)) {\n                            onTokenUpdate();\n                        }\n                    }\n                    return [4 /*yield*/, setFrontTokenToCookie(frontToken, AuthHttpRequest.config.sessionScope)];\n                case 2:\n                    _b.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.setFrontToken = setFrontToken;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}