{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    throw: verb(1),\n    return: verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.responseErrorInterceptor = exports.responseInterceptor = exports.interceptorFunctionRequestFulfilled = void 0;\nvar axiosError_1 = require(\"./axiosError\");\nvar fetch_1 = require(\"./fetch\");\nvar processState_1 = require(\"./processState\");\nvar utils_1 = require(\"./utils\");\nvar windowHandler_1 = require(\"./utils/windowHandler\");\nvar logger_1 = require(\"./logger\");\nfunction getUrlFromConfig(config) {\n  var url = config.url === undefined ? \"\" : config.url;\n  var baseURL = config.baseURL;\n  if (baseURL !== undefined) {\n    if (url.charAt(0) === \"/\" && baseURL.charAt(baseURL.length - 1) === \"/\") {\n      url = baseURL + url.substr(1);\n    } else if (url.charAt(0) !== \"/\" && baseURL.charAt(baseURL.length - 1) !== \"/\") {\n      url = baseURL + \"/\" + url;\n    } else {\n      url = baseURL + url;\n    }\n  }\n  return url;\n}\nfunction interceptorFunctionRequestFulfilled(config) {\n  return __awaiter(this, void 0, void 0, function () {\n    var url, doNotDoInterception, preRequestIdToken, configWithAntiCsrf, antiCsrfToken;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: started axios interception\");\n          url = getUrlFromConfig(config);\n          doNotDoInterception = false;\n          try {\n            doNotDoInterception = typeof url === \"string\" && !(0, utils_1.shouldDoInterceptionBasedOnUrl)(url, fetch_1.default.config.apiDomain, fetch_1.default.config.cookieDomain);\n          } catch (err) {\n            if (err.message === \"Please provide a valid domain name\") {\n              (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Trying shouldDoInterceptionBasedOnUrl with location.origin\");\n              // .origin gives the port as well..\n              doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(), fetch_1.default.config.apiDomain, fetch_1.default.config.cookieDomain);\n            } else {\n              throw err;\n            }\n          }\n          (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Value of doNotDoInterception: \" + doNotDoInterception);\n          if (doNotDoInterception) {\n            (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Returning config unchanged\");\n            // this check means that if you are using axios via inteceptor, then we only do the refresh steps if you are calling your APIs.\n            return [2 /*return*/, config];\n          }\n          (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Modifying config\");\n          processState_1.ProcessState.getInstance().addState(processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST);\n          return [4 /*yield*/, (0, fetch_1.getIdRefreshToken)(true)];\n        case 1:\n          preRequestIdToken = _a.sent();\n          configWithAntiCsrf = config;\n          if (!(preRequestIdToken.status === \"EXISTS\")) return [3 /*break*/, 3];\n          return [4 /*yield*/, fetch_1.AntiCsrfToken.getToken(preRequestIdToken.token)];\n        case 2:\n          antiCsrfToken = _a.sent();\n          if (antiCsrfToken !== undefined) {\n            (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Adding anti-csrf token to request\");\n            configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n              headers: configWithAntiCsrf === undefined ? {\n                \"anti-csrf\": antiCsrfToken\n              } : __assign(__assign({}, configWithAntiCsrf.headers), {\n                \"anti-csrf\": antiCsrfToken\n              })\n            });\n          }\n          _a.label = 3;\n        case 3:\n          if (fetch_1.default.config.autoAddCredentials && configWithAntiCsrf.withCredentials === undefined) {\n            (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Adding credentials include\");\n            configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n              withCredentials: true\n            });\n          }\n          // adding rid for anti-csrf protection: Anti-csrf via custom header\n          (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Adding rid header: anti-csrf (it may be overriden by the user's provided rid)\");\n          configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n            headers: configWithAntiCsrf === undefined ? {\n              rid: \"anti-csrf\"\n            } : __assign({\n              rid: \"anti-csrf\"\n            }, configWithAntiCsrf.headers)\n          });\n          (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: returning modified config\");\n          return [2 /*return*/, configWithAntiCsrf];\n      }\n    });\n  });\n}\nexports.interceptorFunctionRequestFulfilled = interceptorFunctionRequestFulfilled;\nfunction responseInterceptor(axiosInstance) {\n  var _this = this;\n  return function (response) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var doNotDoInterception, url, idRefreshToken, config, antiCsrfToken, tok, frontToken, _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            doNotDoInterception = false;\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1,, 13, 19]);\n            if (!fetch_1.default.initCalled) {\n              throw new Error(\"init function not called\");\n            }\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: started\");\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: already intercepted: \" + response.headers[\"x-supertokens-xhr-intercepted\"]);\n            url = getUrlFromConfig(response.config);\n            try {\n              doNotDoInterception = typeof url === \"string\" && !(0, utils_1.shouldDoInterceptionBasedOnUrl)(url, fetch_1.default.config.apiDomain, fetch_1.default.config.cookieDomain) || !!response.headers[\"x-supertokens-xhr-intercepted\"];\n            } catch (err) {\n              if (err.message === \"Please provide a valid domain name\") {\n                (0, logger_1.logDebugMessage)(\"responseInterceptor: Trying shouldDoInterceptionBasedOnUrl with location.origin\");\n                // .origin gives the port as well..\n                doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(), fetch_1.default.config.apiDomain, fetch_1.default.config.cookieDomain) || !!response.headers[\"x-supertokens-xhr-intercepted\"];\n              } else {\n                throw err;\n              }\n            }\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: Value of doNotDoInterception: \" + doNotDoInterception);\n            if (doNotDoInterception) {\n              (0, logger_1.logDebugMessage)(\"responseInterceptor: Returning without interception\");\n              // this check means that if you are using axios via inteceptor, then we only do the refresh steps if you are calling your APIs.\n              return [2 /*return*/, response];\n            }\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: Interception started\");\n            processState_1.ProcessState.getInstance().addState(processState_1.PROCESS_STATE.CALLING_INTERCEPTION_RESPONSE);\n            idRefreshToken = response.headers[\"id-refresh-token\"];\n            if (!(idRefreshToken !== undefined)) return [3 /*break*/, 3];\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: Setting sIRTFrontend: \" + idRefreshToken);\n            return [4 /*yield*/, (0, fetch_1.setIdRefreshToken)(idRefreshToken, response.status)];\n          case 2:\n            _b.sent();\n            _b.label = 3;\n          case 3:\n            if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode)) return [3 /*break*/, 4];\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: Status code is: \" + response.status);\n            config = response.config;\n            return [2 /*return*/, AuthHttpRequest.doRequest(function (config) {\n              // we create an instance since we don't want to intercept this.\n              // const instance = axios.create();\n              // return instance(config);\n              return axiosInstance(config);\n            }, config, url, response, undefined, true)];\n          case 4:\n            if (!(response.status === fetch_1.default.config.invalidClaimStatusCode)) return [3 /*break*/, 6];\n            // only fire event if body is defined.\n            return [4 /*yield*/, (0, fetch_1.onInvalidClaimResponse)(response)];\n          case 5:\n            // only fire event if body is defined.\n            _b.sent();\n            _b.label = 6;\n          case 6:\n            antiCsrfToken = response.headers[\"anti-csrf\"];\n            if (!(antiCsrfToken !== undefined)) return [3 /*break*/, 9];\n            return [4 /*yield*/, (0, fetch_1.getIdRefreshToken)(true)];\n          case 7:\n            tok = _b.sent();\n            if (!(tok.status === \"EXISTS\")) return [3 /*break*/, 9];\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: Setting anti-csrf token\");\n            return [4 /*yield*/, fetch_1.AntiCsrfToken.setItem(tok.token, antiCsrfToken)];\n          case 8:\n            _b.sent();\n            _b.label = 9;\n          case 9:\n            frontToken = response.headers[\"front-token\"];\n            if (!(frontToken !== undefined)) return [3 /*break*/, 11];\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: Setting sFrontToken: \" + frontToken);\n            return [4 /*yield*/, fetch_1.FrontToken.setItem(frontToken)];\n          case 10:\n            _b.sent();\n            _b.label = 11;\n          case 11:\n            return [2 /*return*/, response];\n          case 12:\n            return [3 /*break*/, 19];\n          case 13:\n            _a = !doNotDoInterception;\n            if (!_a) return [3 /*break*/, 15];\n            return [4 /*yield*/, (0, fetch_1.getIdRefreshToken)(true)];\n          case 14:\n            // we do not call doesSessionExist here cause the user might override that\n            // function here and then it may break the logic of our original implementation.\n            _a = !(_b.sent().status === \"EXISTS\");\n            _b.label = 15;\n          case 15:\n            if (!_a) return [3 /*break*/, 18];\n            (0, logger_1.logDebugMessage)(\"responseInterceptor: sIRTFrontend doesn't exist, so removing anti-csrf and sFrontToken\");\n            return [4 /*yield*/, fetch_1.AntiCsrfToken.removeToken()];\n          case 16:\n            _b.sent();\n            return [4 /*yield*/, fetch_1.FrontToken.removeToken()];\n          case 17:\n            _b.sent();\n            _b.label = 18;\n          case 18:\n            return [7 /*endfinally*/];\n          case 19:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n}\n\nexports.responseInterceptor = responseInterceptor;\nfunction responseErrorInterceptor(axiosInstance) {\n  var _this = this;\n  return function (error) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var config;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            (0, logger_1.logDebugMessage)(\"responseErrorInterceptor: called\");\n            (0, logger_1.logDebugMessage)(\"responseErrorInterceptor: already intercepted: \" + (error.response && error.response.headers[\"x-supertokens-xhr-intercepted\"]));\n            if (error.response.headers[\"x-supertokens-xhr-intercepted\"]) {\n              throw error;\n            }\n            if (!(error.response !== undefined && error.response.status === fetch_1.default.config.sessionExpiredStatusCode)) return [3 /*break*/, 1];\n            (0, logger_1.logDebugMessage)(\"responseErrorInterceptor: Status code is: \" + error.response.status);\n            config = error.config;\n            return [2 /*return*/, AuthHttpRequest.doRequest(function (config) {\n              // we create an instance since we don't want to intercept this.\n              // const instance = axios.create();\n              // return instance(config);\n              return axiosInstance(config);\n            }, config, getUrlFromConfig(config), undefined, error, true)];\n          case 1:\n            if (!(error.response !== undefined && error.response.status === fetch_1.default.config.invalidClaimStatusCode)) return [3 /*break*/, 3];\n            return [4 /*yield*/, (0, fetch_1.onInvalidClaimResponse)(error.response)];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            throw error;\n        }\n      });\n    });\n  };\n}\nexports.responseErrorInterceptor = responseErrorInterceptor;\n/**\n * @class AuthHttpRequest\n * @description wrapper for common http methods.\n */\nvar AuthHttpRequest = /** @class */function () {\n  function AuthHttpRequest() {}\n  var _a;\n  _a = AuthHttpRequest;\n  /**\n   * @description sends the actual http request and returns a response if successful/\n   * If not successful due to session expiry reasons, it\n   * attempts to call the refresh token API and if that is successful, calls this API again.\n   * @throws Error\n   */\n  AuthHttpRequest.doRequest = function (httpCall, config, url, prevResponse, prevError, viaInterceptor) {\n    if (viaInterceptor === void 0) {\n      viaInterceptor = false;\n    }\n    return __awaiter(void 0, void 0, void 0, function () {\n      var doNotDoInterception, returnObj, preRequestIdToken, configWithAntiCsrf, antiCsrfToken, localPrevError, localPrevResponse, response, _b, idRefreshToken, refreshResult, _c, antiCsrfToken, tok, frontToken, err_1, response, idRefreshToken, refreshResult, _d, postRequestIdToken;\n      return __generator(_a, function (_e) {\n        switch (_e.label) {\n          case 0:\n            if (!fetch_1.default.initCalled) {\n              throw Error(\"init function not called\");\n            }\n            (0, logger_1.logDebugMessage)(\"doRequest: called\");\n            doNotDoInterception = false;\n            try {\n              doNotDoInterception = typeof url === \"string\" && !(0, utils_1.shouldDoInterceptionBasedOnUrl)(url, fetch_1.default.config.apiDomain, fetch_1.default.config.cookieDomain) && viaInterceptor;\n            } catch (err) {\n              if (err.message === \"Please provide a valid domain name\") {\n                (0, logger_1.logDebugMessage)(\"doRequest: Trying shouldDoInterceptionBasedOnUrl with location.origin\");\n                // .origin gives the port as well..\n                doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(), fetch_1.default.config.apiDomain, fetch_1.default.config.cookieDomain) && viaInterceptor;\n              } else {\n                throw err;\n              }\n            }\n            (0, logger_1.logDebugMessage)(\"doRequest: Value of doNotDoInterception: \" + doNotDoInterception);\n            if (!doNotDoInterception) return [3 /*break*/, 2];\n            (0, logger_1.logDebugMessage)(\"doRequest: Returning without interception\");\n            if (prevError !== undefined) {\n              throw prevError;\n            } else if (prevResponse !== undefined) {\n              return [2 /*return*/, prevResponse];\n            }\n            return [4 /*yield*/, httpCall(config)];\n          case 1:\n            return [2 /*return*/, _e.sent()];\n          case 2:\n            (0, logger_1.logDebugMessage)(\"doRequest: Interception started\");\n            _e.label = 3;\n          case 3:\n            _e.trys.push([3,, 45, 50]);\n            returnObj = undefined;\n            _e.label = 4;\n          case 4:\n            if (!true) return [3 /*break*/, 44];\n            return [4 /*yield*/, (0, fetch_1.getIdRefreshToken)(true)];\n          case 5:\n            preRequestIdToken = _e.sent();\n            configWithAntiCsrf = config;\n            if (!(preRequestIdToken.status === \"EXISTS\")) return [3 /*break*/, 7];\n            return [4 /*yield*/, fetch_1.AntiCsrfToken.getToken(preRequestIdToken.token)];\n          case 6:\n            antiCsrfToken = _e.sent();\n            if (antiCsrfToken !== undefined) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Adding anti-csrf token to request\");\n              configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                headers: configWithAntiCsrf === undefined ? {\n                  \"anti-csrf\": antiCsrfToken\n                } : __assign(__assign({}, configWithAntiCsrf.headers), {\n                  \"anti-csrf\": antiCsrfToken\n                })\n              });\n            }\n            _e.label = 7;\n          case 7:\n            if (fetch_1.default.config.autoAddCredentials && configWithAntiCsrf.withCredentials === undefined) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Adding credentials include\");\n              configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                withCredentials: true\n              });\n            }\n            // adding rid for anti-csrf protection: Anti-csrf via custom header\n            (0, logger_1.logDebugMessage)(\"doRequest: Adding rid header: anti-csrf (May get overriden by user's rid)\");\n            configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n              headers: configWithAntiCsrf === undefined ? {\n                rid: \"anti-csrf\"\n              } : __assign({\n                rid: \"anti-csrf\"\n              }, configWithAntiCsrf.headers)\n            });\n            _e.label = 8;\n          case 8:\n            _e.trys.push([8, 29,, 43]);\n            localPrevError = prevError;\n            localPrevResponse = prevResponse;\n            prevError = undefined;\n            prevResponse = undefined;\n            if (localPrevError !== undefined) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Not making call because localPrevError is not undefined\");\n              throw localPrevError;\n            }\n            if (localPrevResponse !== undefined) {\n              (0, logger_1.logDebugMessage)(\"doRequest: Not making call because localPrevResponse is not undefined\");\n            } else {\n              (0, logger_1.logDebugMessage)(\"doRequest: Making user's http call\");\n            }\n            if (!(localPrevResponse === undefined)) return [3 /*break*/, 10];\n            return [4 /*yield*/, httpCall(configWithAntiCsrf)];\n          case 9:\n            _b = _e.sent();\n            return [3 /*break*/, 11];\n          case 10:\n            _b = localPrevResponse;\n            _e.label = 11;\n          case 11:\n            response = _b;\n            (0, logger_1.logDebugMessage)(\"doRequest: User's http call ended\");\n            idRefreshToken = response.headers[\"id-refresh-token\"];\n            if (!(idRefreshToken !== undefined)) return [3 /*break*/, 13];\n            (0, logger_1.logDebugMessage)(\"doRequest: Setting sIRTFrontend: \" + idRefreshToken);\n            return [4 /*yield*/, (0, fetch_1.setIdRefreshToken)(idRefreshToken, response.status)];\n          case 12:\n            _e.sent();\n            _e.label = 13;\n          case 13:\n            if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode)) return [3 /*break*/, 20];\n            (0, logger_1.logDebugMessage)(\"doRequest: Status code is: \" + response.status);\n            return [4 /*yield*/, (0, fetch_1.onUnauthorisedResponse)(preRequestIdToken)];\n          case 14:\n            refreshResult = _e.sent();\n            if (!(refreshResult.result !== \"RETRY\")) return [3 /*break*/, 19];\n            (0, logger_1.logDebugMessage)(\"doRequest: Not retrying original request\");\n            if (!refreshResult.error) return [3 /*break*/, 16];\n            return [4 /*yield*/, (0, axiosError_1.createAxiosErrorFromFetchResp)(refreshResult.error)];\n          case 15:\n            _c = _e.sent();\n            return [3 /*break*/, 18];\n          case 16:\n            return [4 /*yield*/, (0, axiosError_1.createAxiosErrorFromAxiosResp)(response)];\n          case 17:\n            _c = _e.sent();\n            _e.label = 18;\n          case 18:\n            // Returning refreshResult.error as an Axios Error if we attempted a refresh\n            // Returning the response to the original response as an error if we did not attempt refreshing\n            returnObj = _c;\n            return [3 /*break*/, 44];\n          case 19:\n            (0, logger_1.logDebugMessage)(\"doRequest: Retrying original request\");\n            return [3 /*break*/, 28];\n          case 20:\n            if (!(response.status === fetch_1.default.config.invalidClaimStatusCode)) return [3 /*break*/, 22];\n            return [4 /*yield*/, (0, fetch_1.onInvalidClaimResponse)(response)];\n          case 21:\n            _e.sent();\n            _e.label = 22;\n          case 22:\n            antiCsrfToken = response.headers[\"anti-csrf\"];\n            if (!(antiCsrfToken !== undefined)) return [3 /*break*/, 25];\n            return [4 /*yield*/, (0, fetch_1.getIdRefreshToken)(true)];\n          case 23:\n            tok = _e.sent();\n            if (!(tok.status === \"EXISTS\")) return [3 /*break*/, 25];\n            (0, logger_1.logDebugMessage)(\"doRequest: Setting anti-csrf token\");\n            return [4 /*yield*/, fetch_1.AntiCsrfToken.setItem(tok.token, antiCsrfToken)];\n          case 24:\n            _e.sent();\n            _e.label = 25;\n          case 25:\n            frontToken = response.headers[\"front-token\"];\n            if (!(frontToken !== undefined)) return [3 /*break*/, 27];\n            (0, logger_1.logDebugMessage)(\"doRequest: Setting sFrontToken: \" + frontToken);\n            return [4 /*yield*/, fetch_1.FrontToken.setItem(frontToken)];\n          case 26:\n            _e.sent();\n            _e.label = 27;\n          case 27:\n            return [2 /*return*/, response];\n          case 28:\n            return [3 /*break*/, 43];\n          case 29:\n            err_1 = _e.sent();\n            response = err_1.response;\n            if (!(response !== undefined)) return [3 /*break*/, 41];\n            idRefreshToken = response.headers[\"id-refresh-token\"];\n            if (!(idRefreshToken !== undefined)) return [3 /*break*/, 31];\n            (0, logger_1.logDebugMessage)(\"doRequest: Setting sIRTFrontend: \" + idRefreshToken);\n            return [4 /*yield*/, (0, fetch_1.setIdRefreshToken)(idRefreshToken, response.status)];\n          case 30:\n            _e.sent();\n            _e.label = 31;\n          case 31:\n            if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode)) return [3 /*break*/, 37];\n            (0, logger_1.logDebugMessage)(\"doRequest: Status code is: \" + response.status);\n            return [4 /*yield*/, (0, fetch_1.onUnauthorisedResponse)(preRequestIdToken)];\n          case 32:\n            refreshResult = _e.sent();\n            if (!(refreshResult.result !== \"RETRY\")) return [3 /*break*/, 36];\n            (0, logger_1.logDebugMessage)(\"doRequest: Not retrying original request\");\n            if (!(refreshResult.error !== undefined)) return [3 /*break*/, 34];\n            return [4 /*yield*/, (0, axiosError_1.createAxiosErrorFromFetchResp)(refreshResult.error)];\n          case 33:\n            _d = _e.sent();\n            return [3 /*break*/, 35];\n          case 34:\n            _d = err_1;\n            _e.label = 35;\n          case 35:\n            // Returning refreshResult.error as an Axios Error if we attempted a refresh\n            // Returning the original error if we did not attempt refreshing\n            returnObj = _d;\n            return [3 /*break*/, 44];\n          case 36:\n            (0, logger_1.logDebugMessage)(\"doRequest: Retrying original request\");\n            return [3 /*break*/, 40];\n          case 37:\n            if (!(response.status === fetch_1.default.config.invalidClaimStatusCode)) return [3 /*break*/, 39];\n            return [4 /*yield*/, (0, fetch_1.onInvalidClaimResponse)(response)];\n          case 38:\n            _e.sent();\n            _e.label = 39;\n          case 39:\n            throw err_1;\n          case 40:\n            return [3 /*break*/, 42];\n          case 41:\n            throw err_1;\n          case 42:\n            return [3 /*break*/, 43];\n          case 43:\n            return [3 /*break*/, 4];\n          case 44:\n            // if it comes here, means we called break. which happens only if we have logged out.\n            // which means it's a 401, so we throw\n            throw returnObj;\n          case 45:\n            return [4 /*yield*/, (0, fetch_1.getIdRefreshToken)(false)];\n          case 46:\n            postRequestIdToken = _e.sent();\n            if (!(postRequestIdToken.status === \"NOT_EXISTS\")) return [3 /*break*/, 49];\n            (0, logger_1.logDebugMessage)(\"doRequest: sIRTFrontend doesn't exist, so removing anti-csrf and sFrontToken\");\n            return [4 /*yield*/, fetch_1.AntiCsrfToken.removeToken()];\n          case 47:\n            _e.sent();\n            return [4 /*yield*/, fetch_1.FrontToken.removeToken()];\n          case 48:\n            _e.sent();\n            _e.label = 49;\n          case 49:\n            return [7 /*endfinally*/];\n          case 50:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return AuthHttpRequest;\n}();\nexports.default = AuthHttpRequest;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","__generator","body","_","label","sent","trys","ops","f","y","g","verb","throw","return","Symbol","iterator","v","op","TypeError","pop","push","defineProperty","exports","responseErrorInterceptor","responseInterceptor","interceptorFunctionRequestFulfilled","axiosError_1","require","fetch_1","processState_1","utils_1","windowHandler_1","logger_1","getUrlFromConfig","config","url","undefined","baseURL","charAt","substr","doNotDoInterception","preRequestIdToken","configWithAntiCsrf","antiCsrfToken","_a","logDebugMessage","shouldDoInterceptionBasedOnUrl","default","apiDomain","cookieDomain","err","message","getReferenceOrThrow","windowHandler","location","getOrigin","ProcessState","getInstance","addState","PROCESS_STATE","CALLING_INTERCEPTION_REQUEST","getIdRefreshToken","status","AntiCsrfToken","getToken","token","headers","autoAddCredentials","withCredentials","rid","axiosInstance","_this","response","idRefreshToken","tok","frontToken","_b","initCalled","Error","CALLING_INTERCEPTION_RESPONSE","setIdRefreshToken","sessionExpiredStatusCode","AuthHttpRequest","doRequest","invalidClaimStatusCode","onInvalidClaimResponse","setItem","FrontToken","removeToken","error","httpCall","prevResponse","prevError","viaInterceptor","returnObj","localPrevError","localPrevResponse","refreshResult","_c","err_1","_d","postRequestIdToken","_e","onUnauthorisedResponse","createAxiosErrorFromFetchResp","createAxiosErrorFromAxiosResp"],"sources":["C:/Users/jsierra/puntodelaguaapp/frontend/node_modules/supertokens-website/lib/build/axios.js"],"sourcesContent":["\"use strict\";\nvar __assign =\n    (this && this.__assign) ||\n    function() {\n        __assign =\n            Object.assign ||\n            function(t) {\n                for (var s, i = 1, n = arguments.length; i < n; i++) {\n                    s = arguments[i];\n                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n                }\n                return t;\n            };\n        return __assign.apply(this, arguments);\n    };\nvar __awaiter =\n    (this && this.__awaiter) ||\n    function(thisArg, _arguments, P, generator) {\n        function adopt(value) {\n            return value instanceof P\n                ? value\n                : new P(function(resolve) {\n                      resolve(value);\n                  });\n        }\n        return new (P || (P = Promise))(function(resolve, reject) {\n            function fulfilled(value) {\n                try {\n                    step(generator.next(value));\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            function rejected(value) {\n                try {\n                    step(generator[\"throw\"](value));\n                } catch (e) {\n                    reject(e);\n                }\n            }\n            function step(result) {\n                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n            }\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n    };\nvar __generator =\n    (this && this.__generator) ||\n    function(thisArg, body) {\n        var _ = {\n                label: 0,\n                sent: function() {\n                    if (t[0] & 1) throw t[1];\n                    return t[1];\n                },\n                trys: [],\n                ops: []\n            },\n            f,\n            y,\n            t,\n            g;\n        return (\n            (g = { next: verb(0), throw: verb(1), return: verb(2) }),\n            typeof Symbol === \"function\" &&\n                (g[Symbol.iterator] = function() {\n                    return this;\n                }),\n            g\n        );\n        function verb(n) {\n            return function(v) {\n                return step([n, v]);\n            };\n        }\n        function step(op) {\n            if (f) throw new TypeError(\"Generator is already executing.\");\n            while (_)\n                try {\n                    if (\n                        ((f = 1),\n                        y &&\n                            (t =\n                                op[0] & 2\n                                    ? y[\"return\"]\n                                    : op[0]\n                                    ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0)\n                                    : y.next) &&\n                            !(t = t.call(y, op[1])).done)\n                    )\n                        return t;\n                    if (((y = 0), t)) op = [op[0] & 2, t.value];\n                    switch (op[0]) {\n                        case 0:\n                        case 1:\n                            t = op;\n                            break;\n                        case 4:\n                            _.label++;\n                            return { value: op[1], done: false };\n                        case 5:\n                            _.label++;\n                            y = op[1];\n                            op = [0];\n                            continue;\n                        case 7:\n                            op = _.ops.pop();\n                            _.trys.pop();\n                            continue;\n                        default:\n                            if (\n                                !((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&\n                                (op[0] === 6 || op[0] === 2)\n                            ) {\n                                _ = 0;\n                                continue;\n                            }\n                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {\n                                _.label = op[1];\n                                break;\n                            }\n                            if (op[0] === 6 && _.label < t[1]) {\n                                _.label = t[1];\n                                t = op;\n                                break;\n                            }\n                            if (t && _.label < t[2]) {\n                                _.label = t[2];\n                                _.ops.push(op);\n                                break;\n                            }\n                            if (t[2]) _.ops.pop();\n                            _.trys.pop();\n                            continue;\n                    }\n                    op = body.call(thisArg, _);\n                } catch (e) {\n                    op = [6, e];\n                    y = 0;\n                } finally {\n                    f = t = 0;\n                }\n            if (op[0] & 5) throw op[1];\n            return { value: op[0] ? op[1] : void 0, done: true };\n        }\n    };\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.responseErrorInterceptor = exports.responseInterceptor = exports.interceptorFunctionRequestFulfilled = void 0;\nvar axiosError_1 = require(\"./axiosError\");\nvar fetch_1 = require(\"./fetch\");\nvar processState_1 = require(\"./processState\");\nvar utils_1 = require(\"./utils\");\nvar windowHandler_1 = require(\"./utils/windowHandler\");\nvar logger_1 = require(\"./logger\");\nfunction getUrlFromConfig(config) {\n    var url = config.url === undefined ? \"\" : config.url;\n    var baseURL = config.baseURL;\n    if (baseURL !== undefined) {\n        if (url.charAt(0) === \"/\" && baseURL.charAt(baseURL.length - 1) === \"/\") {\n            url = baseURL + url.substr(1);\n        } else if (url.charAt(0) !== \"/\" && baseURL.charAt(baseURL.length - 1) !== \"/\") {\n            url = baseURL + \"/\" + url;\n        } else {\n            url = baseURL + url;\n        }\n    }\n    return url;\n}\nfunction interceptorFunctionRequestFulfilled(config) {\n    return __awaiter(this, void 0, void 0, function() {\n        var url, doNotDoInterception, preRequestIdToken, configWithAntiCsrf, antiCsrfToken;\n        return __generator(this, function(_a) {\n            switch (_a.label) {\n                case 0:\n                    (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: started axios interception\");\n                    url = getUrlFromConfig(config);\n                    doNotDoInterception = false;\n                    try {\n                        doNotDoInterception =\n                            typeof url === \"string\" &&\n                            !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                url,\n                                fetch_1.default.config.apiDomain,\n                                fetch_1.default.config.cookieDomain\n                            );\n                    } catch (err) {\n                        if (err.message === \"Please provide a valid domain name\") {\n                            (0, logger_1.logDebugMessage)(\n                                \"interceptorFunctionRequestFulfilled: Trying shouldDoInterceptionBasedOnUrl with location.origin\"\n                            );\n                            // .origin gives the port as well..\n                            doNotDoInterception = !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                windowHandler_1.default.getReferenceOrThrow().windowHandler.location.getOrigin(),\n                                fetch_1.default.config.apiDomain,\n                                fetch_1.default.config.cookieDomain\n                            );\n                        } else {\n                            throw err;\n                        }\n                    }\n                    (0,\n                    logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Value of doNotDoInterception: \" + doNotDoInterception);\n                    if (doNotDoInterception) {\n                        (0, logger_1.logDebugMessage)(\n                            \"interceptorFunctionRequestFulfilled: Returning config unchanged\"\n                        );\n                        // this check means that if you are using axios via inteceptor, then we only do the refresh steps if you are calling your APIs.\n                        return [2 /*return*/, config];\n                    }\n                    (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Modifying config\");\n                    processState_1.ProcessState.getInstance().addState(\n                        processState_1.PROCESS_STATE.CALLING_INTERCEPTION_REQUEST\n                    );\n                    return [4 /*yield*/, (0, fetch_1.getIdRefreshToken)(true)];\n                case 1:\n                    preRequestIdToken = _a.sent();\n                    configWithAntiCsrf = config;\n                    if (!(preRequestIdToken.status === \"EXISTS\")) return [3 /*break*/, 3];\n                    return [4 /*yield*/, fetch_1.AntiCsrfToken.getToken(preRequestIdToken.token)];\n                case 2:\n                    antiCsrfToken = _a.sent();\n                    if (antiCsrfToken !== undefined) {\n                        (0, logger_1.logDebugMessage)(\n                            \"interceptorFunctionRequestFulfilled: Adding anti-csrf token to request\"\n                        );\n                        configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                            headers:\n                                configWithAntiCsrf === undefined\n                                    ? {\n                                          \"anti-csrf\": antiCsrfToken\n                                      }\n                                    : __assign(__assign({}, configWithAntiCsrf.headers), { \"anti-csrf\": antiCsrfToken })\n                        });\n                    }\n                    _a.label = 3;\n                case 3:\n                    if (fetch_1.default.config.autoAddCredentials && configWithAntiCsrf.withCredentials === undefined) {\n                        (0, logger_1.logDebugMessage)(\n                            \"interceptorFunctionRequestFulfilled: Adding credentials include\"\n                        );\n                        configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), { withCredentials: true });\n                    }\n                    // adding rid for anti-csrf protection: Anti-csrf via custom header\n                    (0,\n                    logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: Adding rid header: anti-csrf (it may be overriden by the user's provided rid)\");\n                    configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                        headers:\n                            configWithAntiCsrf === undefined\n                                ? {\n                                      rid: \"anti-csrf\"\n                                  }\n                                : __assign({ rid: \"anti-csrf\" }, configWithAntiCsrf.headers)\n                    });\n                    (0, logger_1.logDebugMessage)(\"interceptorFunctionRequestFulfilled: returning modified config\");\n                    return [2 /*return*/, configWithAntiCsrf];\n            }\n        });\n    });\n}\nexports.interceptorFunctionRequestFulfilled = interceptorFunctionRequestFulfilled;\nfunction responseInterceptor(axiosInstance) {\n    var _this = this;\n    return function(response) {\n        return __awaiter(_this, void 0, void 0, function() {\n            var doNotDoInterception, url, idRefreshToken, config, antiCsrfToken, tok, frontToken, _a;\n            return __generator(this, function(_b) {\n                switch (_b.label) {\n                    case 0:\n                        doNotDoInterception = false;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, , 13, 19]);\n                        if (!fetch_1.default.initCalled) {\n                            throw new Error(\"init function not called\");\n                        }\n                        (0, logger_1.logDebugMessage)(\"responseInterceptor: started\");\n                        (0,\n                        logger_1.logDebugMessage)(\"responseInterceptor: already intercepted: \" + response.headers[\"x-supertokens-xhr-intercepted\"]);\n                        url = getUrlFromConfig(response.config);\n                        try {\n                            doNotDoInterception =\n                                (typeof url === \"string\" &&\n                                    !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                        url,\n                                        fetch_1.default.config.apiDomain,\n                                        fetch_1.default.config.cookieDomain\n                                    )) ||\n                                !!response.headers[\"x-supertokens-xhr-intercepted\"];\n                        } catch (err) {\n                            if (err.message === \"Please provide a valid domain name\") {\n                                (0, logger_1.logDebugMessage)(\n                                    \"responseInterceptor: Trying shouldDoInterceptionBasedOnUrl with location.origin\"\n                                );\n                                // .origin gives the port as well..\n                                doNotDoInterception =\n                                    !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                        windowHandler_1.default\n                                            .getReferenceOrThrow()\n                                            .windowHandler.location.getOrigin(),\n                                        fetch_1.default.config.apiDomain,\n                                        fetch_1.default.config.cookieDomain\n                                    ) || !!response.headers[\"x-supertokens-xhr-intercepted\"];\n                            } else {\n                                throw err;\n                            }\n                        }\n                        (0,\n                        logger_1.logDebugMessage)(\"responseInterceptor: Value of doNotDoInterception: \" + doNotDoInterception);\n                        if (doNotDoInterception) {\n                            (0, logger_1.logDebugMessage)(\"responseInterceptor: Returning without interception\");\n                            // this check means that if you are using axios via inteceptor, then we only do the refresh steps if you are calling your APIs.\n                            return [2 /*return*/, response];\n                        }\n                        (0, logger_1.logDebugMessage)(\"responseInterceptor: Interception started\");\n                        processState_1.ProcessState.getInstance().addState(\n                            processState_1.PROCESS_STATE.CALLING_INTERCEPTION_RESPONSE\n                        );\n                        idRefreshToken = response.headers[\"id-refresh-token\"];\n                        if (!(idRefreshToken !== undefined)) return [3 /*break*/, 3];\n                        (0, logger_1.logDebugMessage)(\"responseInterceptor: Setting sIRTFrontend: \" + idRefreshToken);\n                        return [4 /*yield*/, (0, fetch_1.setIdRefreshToken)(idRefreshToken, response.status)];\n                    case 2:\n                        _b.sent();\n                        _b.label = 3;\n                    case 3:\n                        if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode))\n                            return [3 /*break*/, 4];\n                        (0, logger_1.logDebugMessage)(\"responseInterceptor: Status code is: \" + response.status);\n                        config = response.config;\n                        return [\n                            2 /*return*/,\n                            AuthHttpRequest.doRequest(\n                                function(config) {\n                                    // we create an instance since we don't want to intercept this.\n                                    // const instance = axios.create();\n                                    // return instance(config);\n                                    return axiosInstance(config);\n                                },\n                                config,\n                                url,\n                                response,\n                                undefined,\n                                true\n                            )\n                        ];\n                    case 4:\n                        if (!(response.status === fetch_1.default.config.invalidClaimStatusCode))\n                            return [3 /*break*/, 6];\n                        // only fire event if body is defined.\n                        return [4 /*yield*/, (0, fetch_1.onInvalidClaimResponse)(response)];\n                    case 5:\n                        // only fire event if body is defined.\n                        _b.sent();\n                        _b.label = 6;\n                    case 6:\n                        antiCsrfToken = response.headers[\"anti-csrf\"];\n                        if (!(antiCsrfToken !== undefined)) return [3 /*break*/, 9];\n                        return [4 /*yield*/, (0, fetch_1.getIdRefreshToken)(true)];\n                    case 7:\n                        tok = _b.sent();\n                        if (!(tok.status === \"EXISTS\")) return [3 /*break*/, 9];\n                        (0, logger_1.logDebugMessage)(\"responseInterceptor: Setting anti-csrf token\");\n                        return [4 /*yield*/, fetch_1.AntiCsrfToken.setItem(tok.token, antiCsrfToken)];\n                    case 8:\n                        _b.sent();\n                        _b.label = 9;\n                    case 9:\n                        frontToken = response.headers[\"front-token\"];\n                        if (!(frontToken !== undefined)) return [3 /*break*/, 11];\n                        (0, logger_1.logDebugMessage)(\"responseInterceptor: Setting sFrontToken: \" + frontToken);\n                        return [4 /*yield*/, fetch_1.FrontToken.setItem(frontToken)];\n                    case 10:\n                        _b.sent();\n                        _b.label = 11;\n                    case 11:\n                        return [2 /*return*/, response];\n                    case 12:\n                        return [3 /*break*/, 19];\n                    case 13:\n                        _a = !doNotDoInterception;\n                        if (!_a) return [3 /*break*/, 15];\n                        return [4 /*yield*/, (0, fetch_1.getIdRefreshToken)(true)];\n                    case 14:\n                        // we do not call doesSessionExist here cause the user might override that\n                        // function here and then it may break the logic of our original implementation.\n                        _a = !(_b.sent().status === \"EXISTS\");\n                        _b.label = 15;\n                    case 15:\n                        if (!_a) return [3 /*break*/, 18];\n                        (0,\n                        logger_1.logDebugMessage)(\"responseInterceptor: sIRTFrontend doesn't exist, so removing anti-csrf and sFrontToken\");\n                        return [4 /*yield*/, fetch_1.AntiCsrfToken.removeToken()];\n                    case 16:\n                        _b.sent();\n                        return [4 /*yield*/, fetch_1.FrontToken.removeToken()];\n                    case 17:\n                        _b.sent();\n                        _b.label = 18;\n                    case 18:\n                        return [7 /*endfinally*/];\n                    case 19:\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n}\nexports.responseInterceptor = responseInterceptor;\nfunction responseErrorInterceptor(axiosInstance) {\n    var _this = this;\n    return function(error) {\n        return __awaiter(_this, void 0, void 0, function() {\n            var config;\n            return __generator(this, function(_a) {\n                switch (_a.label) {\n                    case 0:\n                        (0, logger_1.logDebugMessage)(\"responseErrorInterceptor: called\");\n                        (0,\n                        logger_1.logDebugMessage)(\"responseErrorInterceptor: already intercepted: \" + (error.response && error.response.headers[\"x-supertokens-xhr-intercepted\"]));\n                        if (error.response.headers[\"x-supertokens-xhr-intercepted\"]) {\n                            throw error;\n                        }\n                        if (\n                            !(\n                                error.response !== undefined &&\n                                error.response.status === fetch_1.default.config.sessionExpiredStatusCode\n                            )\n                        )\n                            return [3 /*break*/, 1];\n                        (0,\n                        logger_1.logDebugMessage)(\"responseErrorInterceptor: Status code is: \" + error.response.status);\n                        config = error.config;\n                        return [\n                            2 /*return*/,\n                            AuthHttpRequest.doRequest(\n                                function(config) {\n                                    // we create an instance since we don't want to intercept this.\n                                    // const instance = axios.create();\n                                    // return instance(config);\n                                    return axiosInstance(config);\n                                },\n                                config,\n                                getUrlFromConfig(config),\n                                undefined,\n                                error,\n                                true\n                            )\n                        ];\n                    case 1:\n                        if (\n                            !(\n                                error.response !== undefined &&\n                                error.response.status === fetch_1.default.config.invalidClaimStatusCode\n                            )\n                        )\n                            return [3 /*break*/, 3];\n                        return [4 /*yield*/, (0, fetch_1.onInvalidClaimResponse)(error.response)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        throw error;\n                }\n            });\n        });\n    };\n}\nexports.responseErrorInterceptor = responseErrorInterceptor;\n/**\n * @class AuthHttpRequest\n * @description wrapper for common http methods.\n */\nvar AuthHttpRequest = /** @class */ (function() {\n    function AuthHttpRequest() {}\n    var _a;\n    _a = AuthHttpRequest;\n    /**\n     * @description sends the actual http request and returns a response if successful/\n     * If not successful due to session expiry reasons, it\n     * attempts to call the refresh token API and if that is successful, calls this API again.\n     * @throws Error\n     */\n    AuthHttpRequest.doRequest = function(httpCall, config, url, prevResponse, prevError, viaInterceptor) {\n        if (viaInterceptor === void 0) {\n            viaInterceptor = false;\n        }\n        return __awaiter(void 0, void 0, void 0, function() {\n            var doNotDoInterception,\n                returnObj,\n                preRequestIdToken,\n                configWithAntiCsrf,\n                antiCsrfToken,\n                localPrevError,\n                localPrevResponse,\n                response,\n                _b,\n                idRefreshToken,\n                refreshResult,\n                _c,\n                antiCsrfToken,\n                tok,\n                frontToken,\n                err_1,\n                response,\n                idRefreshToken,\n                refreshResult,\n                _d,\n                postRequestIdToken;\n            return __generator(_a, function(_e) {\n                switch (_e.label) {\n                    case 0:\n                        if (!fetch_1.default.initCalled) {\n                            throw Error(\"init function not called\");\n                        }\n                        (0, logger_1.logDebugMessage)(\"doRequest: called\");\n                        doNotDoInterception = false;\n                        try {\n                            doNotDoInterception =\n                                typeof url === \"string\" &&\n                                !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                    url,\n                                    fetch_1.default.config.apiDomain,\n                                    fetch_1.default.config.cookieDomain\n                                ) &&\n                                viaInterceptor;\n                        } catch (err) {\n                            if (err.message === \"Please provide a valid domain name\") {\n                                (0, logger_1.logDebugMessage)(\n                                    \"doRequest: Trying shouldDoInterceptionBasedOnUrl with location.origin\"\n                                );\n                                // .origin gives the port as well..\n                                doNotDoInterception =\n                                    !(0, utils_1.shouldDoInterceptionBasedOnUrl)(\n                                        windowHandler_1.default\n                                            .getReferenceOrThrow()\n                                            .windowHandler.location.getOrigin(),\n                                        fetch_1.default.config.apiDomain,\n                                        fetch_1.default.config.cookieDomain\n                                    ) && viaInterceptor;\n                            } else {\n                                throw err;\n                            }\n                        }\n                        (0,\n                        logger_1.logDebugMessage)(\"doRequest: Value of doNotDoInterception: \" + doNotDoInterception);\n                        if (!doNotDoInterception) return [3 /*break*/, 2];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Returning without interception\");\n                        if (prevError !== undefined) {\n                            throw prevError;\n                        } else if (prevResponse !== undefined) {\n                            return [2 /*return*/, prevResponse];\n                        }\n                        return [4 /*yield*/, httpCall(config)];\n                    case 1:\n                        return [2 /*return*/, _e.sent()];\n                    case 2:\n                        (0, logger_1.logDebugMessage)(\"doRequest: Interception started\");\n                        _e.label = 3;\n                    case 3:\n                        _e.trys.push([3, , 45, 50]);\n                        returnObj = undefined;\n                        _e.label = 4;\n                    case 4:\n                        if (!true) return [3 /*break*/, 44];\n                        return [4 /*yield*/, (0, fetch_1.getIdRefreshToken)(true)];\n                    case 5:\n                        preRequestIdToken = _e.sent();\n                        configWithAntiCsrf = config;\n                        if (!(preRequestIdToken.status === \"EXISTS\")) return [3 /*break*/, 7];\n                        return [4 /*yield*/, fetch_1.AntiCsrfToken.getToken(preRequestIdToken.token)];\n                    case 6:\n                        antiCsrfToken = _e.sent();\n                        if (antiCsrfToken !== undefined) {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Adding anti-csrf token to request\");\n                            configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                                headers:\n                                    configWithAntiCsrf === undefined\n                                        ? {\n                                              \"anti-csrf\": antiCsrfToken\n                                          }\n                                        : __assign(__assign({}, configWithAntiCsrf.headers), {\n                                              \"anti-csrf\": antiCsrfToken\n                                          })\n                            });\n                        }\n                        _e.label = 7;\n                    case 7:\n                        if (\n                            fetch_1.default.config.autoAddCredentials &&\n                            configWithAntiCsrf.withCredentials === undefined\n                        ) {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Adding credentials include\");\n                            configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), { withCredentials: true });\n                        }\n                        // adding rid for anti-csrf protection: Anti-csrf via custom header\n                        (0,\n                        logger_1.logDebugMessage)(\"doRequest: Adding rid header: anti-csrf (May get overriden by user's rid)\");\n                        configWithAntiCsrf = __assign(__assign({}, configWithAntiCsrf), {\n                            headers:\n                                configWithAntiCsrf === undefined\n                                    ? {\n                                          rid: \"anti-csrf\"\n                                      }\n                                    : __assign({ rid: \"anti-csrf\" }, configWithAntiCsrf.headers)\n                        });\n                        _e.label = 8;\n                    case 8:\n                        _e.trys.push([8, 29, , 43]);\n                        localPrevError = prevError;\n                        localPrevResponse = prevResponse;\n                        prevError = undefined;\n                        prevResponse = undefined;\n                        if (localPrevError !== undefined) {\n                            (0, logger_1.logDebugMessage)(\n                                \"doRequest: Not making call because localPrevError is not undefined\"\n                            );\n                            throw localPrevError;\n                        }\n                        if (localPrevResponse !== undefined) {\n                            (0, logger_1.logDebugMessage)(\n                                \"doRequest: Not making call because localPrevResponse is not undefined\"\n                            );\n                        } else {\n                            (0, logger_1.logDebugMessage)(\"doRequest: Making user's http call\");\n                        }\n                        if (!(localPrevResponse === undefined)) return [3 /*break*/, 10];\n                        return [4 /*yield*/, httpCall(configWithAntiCsrf)];\n                    case 9:\n                        _b = _e.sent();\n                        return [3 /*break*/, 11];\n                    case 10:\n                        _b = localPrevResponse;\n                        _e.label = 11;\n                    case 11:\n                        response = _b;\n                        (0, logger_1.logDebugMessage)(\"doRequest: User's http call ended\");\n                        idRefreshToken = response.headers[\"id-refresh-token\"];\n                        if (!(idRefreshToken !== undefined)) return [3 /*break*/, 13];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Setting sIRTFrontend: \" + idRefreshToken);\n                        return [4 /*yield*/, (0, fetch_1.setIdRefreshToken)(idRefreshToken, response.status)];\n                    case 12:\n                        _e.sent();\n                        _e.label = 13;\n                    case 13:\n                        if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode))\n                            return [3 /*break*/, 20];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Status code is: \" + response.status);\n                        return [4 /*yield*/, (0, fetch_1.onUnauthorisedResponse)(preRequestIdToken)];\n                    case 14:\n                        refreshResult = _e.sent();\n                        if (!(refreshResult.result !== \"RETRY\")) return [3 /*break*/, 19];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Not retrying original request\");\n                        if (!refreshResult.error) return [3 /*break*/, 16];\n                        return [4 /*yield*/, (0, axiosError_1.createAxiosErrorFromFetchResp)(refreshResult.error)];\n                    case 15:\n                        _c = _e.sent();\n                        return [3 /*break*/, 18];\n                    case 16:\n                        return [4 /*yield*/, (0, axiosError_1.createAxiosErrorFromAxiosResp)(response)];\n                    case 17:\n                        _c = _e.sent();\n                        _e.label = 18;\n                    case 18:\n                        // Returning refreshResult.error as an Axios Error if we attempted a refresh\n                        // Returning the response to the original response as an error if we did not attempt refreshing\n                        returnObj = _c;\n                        return [3 /*break*/, 44];\n                    case 19:\n                        (0, logger_1.logDebugMessage)(\"doRequest: Retrying original request\");\n                        return [3 /*break*/, 28];\n                    case 20:\n                        if (!(response.status === fetch_1.default.config.invalidClaimStatusCode))\n                            return [3 /*break*/, 22];\n                        return [4 /*yield*/, (0, fetch_1.onInvalidClaimResponse)(response)];\n                    case 21:\n                        _e.sent();\n                        _e.label = 22;\n                    case 22:\n                        antiCsrfToken = response.headers[\"anti-csrf\"];\n                        if (!(antiCsrfToken !== undefined)) return [3 /*break*/, 25];\n                        return [4 /*yield*/, (0, fetch_1.getIdRefreshToken)(true)];\n                    case 23:\n                        tok = _e.sent();\n                        if (!(tok.status === \"EXISTS\")) return [3 /*break*/, 25];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Setting anti-csrf token\");\n                        return [4 /*yield*/, fetch_1.AntiCsrfToken.setItem(tok.token, antiCsrfToken)];\n                    case 24:\n                        _e.sent();\n                        _e.label = 25;\n                    case 25:\n                        frontToken = response.headers[\"front-token\"];\n                        if (!(frontToken !== undefined)) return [3 /*break*/, 27];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Setting sFrontToken: \" + frontToken);\n                        return [4 /*yield*/, fetch_1.FrontToken.setItem(frontToken)];\n                    case 26:\n                        _e.sent();\n                        _e.label = 27;\n                    case 27:\n                        return [2 /*return*/, response];\n                    case 28:\n                        return [3 /*break*/, 43];\n                    case 29:\n                        err_1 = _e.sent();\n                        response = err_1.response;\n                        if (!(response !== undefined)) return [3 /*break*/, 41];\n                        idRefreshToken = response.headers[\"id-refresh-token\"];\n                        if (!(idRefreshToken !== undefined)) return [3 /*break*/, 31];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Setting sIRTFrontend: \" + idRefreshToken);\n                        return [4 /*yield*/, (0, fetch_1.setIdRefreshToken)(idRefreshToken, response.status)];\n                    case 30:\n                        _e.sent();\n                        _e.label = 31;\n                    case 31:\n                        if (!(response.status === fetch_1.default.config.sessionExpiredStatusCode))\n                            return [3 /*break*/, 37];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Status code is: \" + response.status);\n                        return [4 /*yield*/, (0, fetch_1.onUnauthorisedResponse)(preRequestIdToken)];\n                    case 32:\n                        refreshResult = _e.sent();\n                        if (!(refreshResult.result !== \"RETRY\")) return [3 /*break*/, 36];\n                        (0, logger_1.logDebugMessage)(\"doRequest: Not retrying original request\");\n                        if (!(refreshResult.error !== undefined)) return [3 /*break*/, 34];\n                        return [4 /*yield*/, (0, axiosError_1.createAxiosErrorFromFetchResp)(refreshResult.error)];\n                    case 33:\n                        _d = _e.sent();\n                        return [3 /*break*/, 35];\n                    case 34:\n                        _d = err_1;\n                        _e.label = 35;\n                    case 35:\n                        // Returning refreshResult.error as an Axios Error if we attempted a refresh\n                        // Returning the original error if we did not attempt refreshing\n                        returnObj = _d;\n                        return [3 /*break*/, 44];\n                    case 36:\n                        (0, logger_1.logDebugMessage)(\"doRequest: Retrying original request\");\n                        return [3 /*break*/, 40];\n                    case 37:\n                        if (!(response.status === fetch_1.default.config.invalidClaimStatusCode))\n                            return [3 /*break*/, 39];\n                        return [4 /*yield*/, (0, fetch_1.onInvalidClaimResponse)(response)];\n                    case 38:\n                        _e.sent();\n                        _e.label = 39;\n                    case 39:\n                        throw err_1;\n                    case 40:\n                        return [3 /*break*/, 42];\n                    case 41:\n                        throw err_1;\n                    case 42:\n                        return [3 /*break*/, 43];\n                    case 43:\n                        return [3 /*break*/, 4];\n                    case 44:\n                        // if it comes here, means we called break. which happens only if we have logged out.\n                        // which means it's a 401, so we throw\n                        throw returnObj;\n                    case 45:\n                        return [4 /*yield*/, (0, fetch_1.getIdRefreshToken)(false)];\n                    case 46:\n                        postRequestIdToken = _e.sent();\n                        if (!(postRequestIdToken.status === \"NOT_EXISTS\")) return [3 /*break*/, 49];\n                        (0,\n                        logger_1.logDebugMessage)(\"doRequest: sIRTFrontend doesn't exist, so removing anti-csrf and sFrontToken\");\n                        return [4 /*yield*/, fetch_1.AntiCsrfToken.removeToken()];\n                    case 47:\n                        _e.sent();\n                        return [4 /*yield*/, fetch_1.FrontToken.removeToken()];\n                    case 48:\n                        _e.sent();\n                        _e.label = 49;\n                    case 49:\n                        return [7 /*endfinally*/];\n                    case 50:\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return AuthHttpRequest;\n})();\nexports.default = AuthHttpRequest;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}